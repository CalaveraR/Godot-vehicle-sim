# res://core/build/ContactPatchBuilder.gd
class_name ContactPatchBuilder
extends RefCounted

# -----------------------------------------------------------------------------
# DEPENDÊNCIAS E CONFIGURAÇÃO
# -----------------------------------------------------------------------------
# Política externa contendo parâmetros técnicos e regras de negócio.
# Se não fornecida, usa valores padrão (modo fallback).
@export var policy: ContactPolicy = null

# Parâmetros locais usados quando policy não está disponível
var _default_confidence_threshold: float = 0.55
var _default_grid_width: int = 90


# -----------------------------------------------------------------------------
# API PÚBLICA
# -----------------------------------------------------------------------------
# Constrói um ContactPatch a partir de amostras do shader e raycasts,
# aplicando blending adaptativo, filtragem e metadados temporais.
func build_contact_patch(
	shader_samples: Array[TireSample],
	raycast_samples: Array[TireSample],
	history: TemporalHistory
) -> ContactPatch:
	
	var blended_samples = _blend_samples(shader_samples, raycast_samples, history)
	var valid_samples = _filter_valid_samples(blended_samples)
	var time = Time.get_ticks_msec() / 1000.0
	
	return ContactPatch.new(valid_samples, time)


# -----------------------------------------------------------------------------
# MÉTODOS INTERNOS DE BLENDING E FALLBACK
# -----------------------------------------------------------------------------
# Combina amostras do shader com raycasts, respeitando confiança e
# tratando normais inválidas (Vector3.ZERO) com fallback completo.
func _blend_samples(
	shader_samples: Array[TireSample],
	raycast_samples: Array[TireSample],
	history: TemporalHistory
) -> Array[TireSample]:
	
	var blended: Array[TireSample] = []
	var threshold = _get_confidence_threshold()
	
	for shader_sample in shader_samples:
		var blended_sample = shader_sample.duplicate()
		
		# Confiança baixa → busca raycast próximo para blend
		if shader_sample.confidence < threshold:
			var nearest_raycast = _find_nearest_raycast(
				shader_sample.grid_x,
				raycast_samples
			)
			
			if nearest_raycast:
				# Fator de blend = 1 - confiança (quanto menor a confiança, mais raycast)
				var blend = 1.0 - shader_sample.confidence
				
				# Penetração: blend linear
				blended_sample.penetration = lerp(
					shader_sample.penetration,
					nearest_raycast.penetration,
					blend
				)
				
				# --- TRATAMENTO ROBUSTO DE NORMAL ZERO ---
				# Se a normal do shader for zero, confiança é ignorada e usamos fallback completo.
				var use_full_raycast_normal = shader_sample.normal == Vector3.ZERO
				
				if use_full_raycast_normal:
					blended_sample.normal = nearest_raycast.normal
				else:
					# Slerp normal com blend limitado a 1.0
					blended_sample.normal = blended_sample.normal.slerp(
						nearest_raycast.normal,
						min(blend, 1.0)
					)
				
				# Confiança final: maior entre as duas fontes (ou no mínimo 0.1 para evitar filtragem)
				blended_sample.confidence = max(
					shader_sample.confidence,
					nearest_raycast.confidence,
					0.1
				)
				blended_sample.source_type = TireSample.SOURCE_BLENDED
		
		blended.append(blended_sample)
	
	return blended


# Retorna a amostra de raycast com grid_x mais próximo do índice informado.
func _find_nearest_raycast(grid_x: int, raycasts: Array[TireSample]) -> TireSample:
	var best: TireSample = null
	var best_dist = INF
	
	for raycast in raycasts:
		var dist = abs(raycast.grid_x - grid_x)
		if dist < best_dist:
			best_dist = dist
			best = raycast
	
	return best


# -----------------------------------------------------------------------------
# FILTRAGEM
# -----------------------------------------------------------------------------
# Mantém apenas amostras com penetração positiva e confiança > 0.
func _filter_valid_samples(samples: Array[TireSample]) -> Array[TireSample]:
	var valid: Array[TireSample] = []
	
	for sample in samples:
		if sample.penetration > 0.0 and sample.confidence > 0.0:
			valid.append(sample)
	
	return valid


# -----------------------------------------------------------------------------
# SUPORTE A POLÍTICA (CONTACT POLICY)
# -----------------------------------------------------------------------------
# Retorna o limiar de confiança definido pela política, ou o padrão local.
func _get_confidence_threshold() -> float:
	if policy and policy.has_method("get_confidence_threshold"):
		return policy.get_confidence_threshold()
	return _default_confidence_threshold


# Retorna a largura da grade definida pela política, ou o padrão local.
func _get_grid_width() -> int:
	if policy and policy.has_method("get_grid_width"):
		return policy.get_grid_width()
	return _default_grid_width


# -----------------------------------------------------------------------------
# NOTAS DE RESPONSABILIDADE
# -----------------------------------------------------------------------------
# ✅ Responsabilidades cumpridas:
#   - Blend de dados de múltiplas fontes (shader + raycast)
#   - Fallback completo para normais zero
#   - Filtragem de amostras inválidas
#   - Construção do ContactPatch com timestamp
#   - Separação de parâmetros via ContactPolicy (extensível)
#
# ❌ Não é responsável por:
#   - Aplicação de forças físicas
#   - Modificação da simulação
#   - Decisões de gameplay