# res://core/contracts/ApplyInfluenceToShaderState.gd
class_name ApplyInfluenceToShaderState
extends RefCounted

# -------------------------------------------------------------------------- #
# Contrato de influência neutra (encapsula dados para aplicação determinística)
# -------------------------------------------------------------------------- #
class NeutralInfluenceContract extends RefCounted:
    var allow_influence: bool = false
    var mode: String = "none"          # "clamp", "bias", "fallback", "none"
    var targets: Dictionary = {}       # ex: { "penetration": true, "confidence": true }
    var limits: Dictionary = {}        # ex: { "max_penetration": 0.1, "min_confidence": 0.3 }
    var weights: Dictionary = {}       # ex: { "penetration_weight": 0.7 }
    var reason: String = ""           # metadado opcional

    func _init(
        p_allow: bool = false,
        p_mode: String = "none",
        p_targets: Dictionary = {},
        p_limits: Dictionary = {},
        p_weights: Dictionary = {},
        p_reason: String = ""
    ):
        allow_influence = p_allow
        mode = p_mode
        targets = p_targets
        limits = p_limits
        weights = p_weights
        reason = p_reason


# -------------------------------------------------------------------------- #
# Aplicador principal – influência neutra de raycasts no estado do shader
# -------------------------------------------------------------------------- #

func apply(shader_state: Dictionary, contract: NeutralInfluenceContract) -> Dictionary:
    """
    Aplica influência dos raycasts de forma neutra e determinística.
    - NÃO decide se deve aplicar (já decidido por evaluate_raycast_influence)
    - NÃO calcula forças ou física
    - NÃO gera novos dados
    - Apenas clampa, pondera ou limita valores existentes
    - Preserva dados originais do shader quando possível
    """
    var result_state = shader_state.duplicate(true)

    if not contract.allow_influence:
        return result_state

    match contract.mode:
        "clamp":
            result_state = _apply_clamp_mode(result_state, contract.targets, contract.limits)
        "bias":
            result_state = _apply_bias_mode(result_state, contract.targets, contract.limits, contract.weights)
        "fallback":
            result_state = _apply_fallback_mode(result_state, contract.limits)
        _:  # "none" ou qualquer outro
            return result_state

    # Metadado de influência aplicada
    result_state["raycast_influence_applied"] = {
        "mode": contract.mode,
        "timestamp": Time.get_ticks_msec(),
        "contract": contract.reason
    }

    return result_state


func _apply_clamp_mode(
    shader_state: Dictionary,
    targets: Dictionary,
    limits: Dictionary
) -> Dictionary:
    """Apenas limita valores fisicamente implausíveis."""
    var result = shader_state.duplicate(true)

    if targets.get("penetration", false):
        var current_pen = shader_state.get("avg_penetration", 0.0)
        var max_pen = limits.get("max_penetration", INF)
        if current_pen > max_pen:
            result["avg_penetration"] = max_pen
            result["clamp_applied"] = result.get("clamp_applied", 0) + 1

    if targets.get("contact_width", false):
        var current_width = shader_state.get("contact_width", 0.0)
        var max_width = limits.get("max_contact_width", INF)
        if current_width > max_width:
            result["contact_width"] = max_width
            result["clamp_applied"] = result.get("clamp_applied", 0) + 1

    if targets.get("confidence", false):
        var current_conf = shader_state.get("confidence", 1.0)
        var min_conf = limits.get("min_confidence", 0.0)
        if current_conf < min_conf:
            result["confidence"] = min_conf
            result["clamp_applied"] = result.get("clamp_applied", 0) + 1

    # NOTA: Normal NUNCA é alterada em modo clamp.
    # NOTA: Regiões de ativação NUNCA são alteradas em modo clamp.

    return result


func _apply_bias_mode(
    shader_state: Dictionary,
    targets: Dictionary,
    limits: Dictionary,
    weights: Dictionary
) -> Dictionary:
    """Interpolação ponderada entre shader e limites do raycast."""
    var result = shader_state.duplicate(true)

    if targets.get("penetration", false):
        var current_pen = shader_state.get("avg_penetration", 0.0)
        var max_pen = limits.get("max_penetration", current_pen)
        var weight = weights.get("penetration_weight", 0.0)
        var biased_pen = lerp(current_pen, max_pen, weight)
        result["avg_penetration"] = biased_pen
        result["bias_applied"] = result.get("bias_applied", 0) + 1

    if targets.get("confidence", false):
        var current_conf = shader_state.get("confidence", 1.0)
        var min_conf = limits.get("min_confidence", current_conf)
        var weight = weights.get("confidence_weight", 0.0)
        var biased_conf = lerp(current_conf, min_conf, weight)
        result["confidence"] = biased_conf
        result["bias_applied"] = result.get("bias_applied", 0) + 1

    if targets.get("contact_width", false):
        var current_width = shader_state.get("contact_width", 0.0)
        var max_width = limits.get("max_contact_width", current_width)
        var weight = weights.get("width_weight", 0.0)
        var biased_width = lerp(current_width, max_width, weight)
        result["contact_width"] = biased_width
        result["bias_applied"] = result.get("bias_applied", 0) + 1

    # NOTA: Normal NUNCA é alterada em modo bias.
    # NOTA: Regiões de ativação podem ser ajustadas, mas não removidas.

    return result


func _apply_fallback_mode(
    shader_state: Dictionary,
    limits: Dictionary
) -> Dictionary:
    """Fornece dados geométricos mínimos de emergência (shader falhou)."""
    var result = {
        "mode": "raycast_fallback",
        "has_contact": false,
        "confidence": 0.1,
        "avg_penetration": 0.0,
        "contact_width": 0.0,
        "fallback_source": "raycast_anchor",
        "timestamp": Time.get_ticks_msec(),
        "warning": "Usando dados de fallback do raycast - física limitada"
    }

    result["limits_applied"] = {
        "max_penetration": limits.get("max_penetration", 0.0),
        "reference_plane_normal": limits.get("reference_plane_normal", Vector3.UP),
        "reference_plane_height": limits.get("reference_plane_height", 0.0)
    }

    # NOTA: Nenhuma força é calculada aqui.
    # NOTA: O sistema deve tratar este estado como "dados de referência apenas".

    return result