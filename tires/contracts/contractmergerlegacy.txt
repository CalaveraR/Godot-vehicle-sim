class_name ContractMerger
extends Node

# Fusor de Contratos
# Responsabilidades:
# - Classe ContractMerger com prioridades de modo/autoridade
# - Fusão de múltiplos contratos em um único contrato
# - Cálculo de médias ponderadas por plausibilidade
# - Resolução de conflitos (priorizar segurança)
# - Preservação de flags de segurança em contratos fundidos
#
# Conecta com:
# - influence_contract_system.gd (recebe contratos para fusão)
# - contract_rate_limiter.gd (pode receber contratos neutros)
# - raycast_anchor_hybrid_main.gd (orquestração principal)
#
# Configuração esperada:
# - Pesos para diferentes modos e autoridades
# - Estratégias de fusão (média, prioridade máxima, etc.)
# - Limiares para resolução de conflitos

# Enums para estratégias de fusão
enum MergeStrategy {
    STRATEGY_WEIGHTED_AVERAGE,     # Média ponderada
    STRATEGY_PRIORITY_MAX,         # Usa valor de maior prioridade
    STRATEGY_SAFETY_FIRST,         # Prioriza segurança sobre tudo
    STRATEGY_CONSENSUS             # Requer consenso entre contratos
}

# Enums para modos de resolução de conflitos
enum ConflictResolution {
    RESOLUTION_SAFETY,             # Resolver a favor da segurança
    RESOLUTION_CONSERVATIVE,       # Resolver conservadoramente (valores menores)
    RESOLUTION_AVERAGE,            # Usar média
    RESOLUTION_HIGHEST_CONFIDENCE  # Usar contrato com maior confiança
}

# Estrutura para resultado de fusão
class MergeResult:
    var merged_contract: Dictionary = {}
    var source_contracts: Array = []  # IDs ou referências dos contratos originais
    var merge_confidence: float = 0.0  # Confiança do resultado fundido
    var conflicts_resolved: int = 0
    var safety_flags_preserved: Array[String] = []
    var was_trivial: bool = false  # True se apenas um contrato foi fundido
    
    func _init():
        merged_contract = {
            "mode": 0,
            "authority": 0,
            "confidence": 0.0,
            "influence_weight": 0.0,
            "safety_flags": [],
            "data": {},
            "timestamp": 0.0,
            "is_merged": true,
            "merge_strategy": 0,
            "source_count": 0
        }

# Classe principal do fusor de contratos
class ContractMergerInstance:
    var merge_strategy: int = MergeStrategy.STRATEGY_WEIGHTED_AVERAGE
    var conflict_resolution: int = ConflictResolution.RESOLUTION_SAFETY
    var min_contracts_for_consensus: int = 2
    var consensus_threshold: float = 0.7  # 70% de concordância
    var safety_priority_multiplier: float = 2.0  # Multiplicador para prioridade de segurança
    
    # Pesos para diferentes modos (usando ContractMode de influence_contract_system)
    var mode_weights: Dictionary = {
        0: 0.3,  # MODE_CLAMP
        1: 0.6,  # MODE_BIAS
        2: 0.9   # MODE_GEOMETRY_REFERENCE
    }
    
    # Pesos para diferentes autoridades (usando ContractAuthority de influence_contract_system)
    var authority_weights: Dictionary = {
        0: 0.1,  # AUTHORITY_NONE
        1: 0.3,  # AUTHORITY_LOW
        2: 0.6,  # AUTHORITY_MEDIUM
        3: 0.8,  # AUTHORITY_HIGH
        4: 1.0   # AUTHORITY_CRITICAL
    }
    
    # Histórico de fusões
    var merge_history: Array[Dictionary] = []
    var max_history_size: int = 100
    
    func _init():
        pass
    
    func merge_contracts(contracts: Array) -> MergeResult:
        """Funde múltiplos contratos em um único contrato."""
        var result: MergeResult = MergeResult.new()
        
        # Caso trivial: apenas um contrato
        if contracts.size() == 1:
            result.was_trivial = true
            result.merged_contract = _convert_to_merged_format(contracts[0])
            result.merged_contract.source_count = 1
            result.merge_confidence = contracts[0].confidence
            result.source_contracts = [contracts[0].source_id]
            _add_to_history(result, contracts)
            return result
        
        # Caso: múltiplos contratos
        result.source_contracts = _extract_source_ids(contracts)
        result.merged_contract.source_count = contracts.size()
        result.merged_contract.merge_strategy = merge_strategy
        
        # Filtrar contratos inválidos
        var valid_contracts: Array = _filter_valid_contracts(contracts)
        if valid_contracts.is_empty():
            # Todos inválidos - retornar contrato neutro
            result.merged_contract = _create_neutral_contract()
            result.merge_confidence = 0.1
            _add_to_history(result, contracts)
            return result
        
        # Aplicar estratégia de fusão
        match merge_strategy:
            MergeStrategy.STRATEGY_WEIGHTED_AVERAGE:
                result = _merge_weighted_average(valid_contracts, result)
            MergeStrategy.STRATEGY_PRIORITY_MAX:
                result = _merge_priority_max(valid_contracts, result)
            MergeStrategy.STRATEGY_SAFETY_FIRST:
                result = _merge_safety_first(valid_contracts, result)
            MergeStrategy.STRATEGY_CONSENSUS:
                result = _merge_consensus(valid_contracts, result)
            _:
                result = _merge_weighted_average(valid_contracts, result)
        
        # Preservar flags de segurança
        result.safety_flags_preserved = _merge_safety_flags(valid_contracts)
        result.merged_contract.safety_flags = result.safety_flags_preserved
        
        # Calcular confiança final
        result.merge_confidence = _calculate_merge_confidence(valid_contracts, result.conflicts_resolved)
        result.merged_contract.confidence = result.merge_confidence
        
        # Atualizar timestamp
        result.merged_contract.timestamp = Time.get_ticks_msec() / 1000.0
        
        _add_to_history(result, contracts)
        return result
    
    func _merge_weighted_average(contracts: Array, base_result: MergeResult) -> MergeResult:
        """Fusão por média ponderada."""
        var result: MergeResult = base_result
        var total_weight: float = 0.0
        
        # Estruturas para acumular valores ponderados
        var mode_accumulator: Dictionary = {}  # mode -> weight
        var authority_accumulator: Dictionary = {}  # authority -> weight
        var data_accumulators: Dictionary = {}  # key -> {sum, weight}
        var confidence_sum: float = 0.0
        var influence_weight_sum: float = 0.0
        
        for contract in contracts:
            var weight: float = _calculate_contract_weight(contract)
            total_weight += weight
            
            # Acumular modo
            var mode: int = contract.mode
            mode_accumulator[mode] = mode_accumulator.get(mode, 0.0) + weight
            
            # Acumular autoridade
            var authority: int = contract.authority
            authority_accumulator[authority] = authority_accumulator.get(authority, 0.0) + weight
            
            # Acumular confiança e peso de influência
            confidence_sum += contract.confidence * weight
            influence_weight_sum += contract.influence_weight * weight
            
            # Acumular dados
            for key in contract.data.keys():
                var value = contract.data[key]
                if not data_accumulators.has(key):
                    data_accumulators[key] = {"sum": 0.0, "weight": 0.0}
                
                if typeof(value) == TYPE_FLOAT:
                    data_accumulators[key].sum += value * weight
                    data_accumulators[key].weight += weight
                elif typeof(value) == TYPE_VECTOR3:
                    # Para vetores, acumular componentes separadamente
                    if not data_accumulators.has(key + "_x"):
                        data_accumulators[key + "_x"] = {"sum": 0.0, "weight": 0.0}
                        data_accumulators[key + "_y"] = {"sum": 0.0, "weight": 0.0}
                        data_accumulators[key + "_z"] = {"sum": 0.0, "weight": 0.0}
                    
                    data_accumulators[key + "_x"].sum += value.x * weight
                    data_accumulators[key + "_x"].weight += weight
                    data_accumulators[key + "_y"].sum += value.y * weight
                    data_accumulators[key + "_y"].weight += weight
                    data_accumulators[key + "_z"].sum += value.z * weight
                    data_accumulators[key + "_z"].weight += weight
        
        # Calcular valores finais
        if total_weight > 0:
            # Modo (maior peso)
            var best_mode: int = _get_key_with_max_weight(mode_accumulator)
            result.merged_contract.mode = best_mode
            
            # Autoridade (maior peso)
            var best_authority: int = _get_key_with_max_weight(authority_accumulator)
            result.merged_contract.authority = best_authority
            
            # Confiança e peso de influência (média ponderada)
            result.merged_contract.confidence = confidence_sum / total_weight
            result.merged_contract.influence_weight = influence_weight_sum / total_weight
            
            # Dados
            result.merged_contract.data = _merge_data_weighted(data_accumulators, total_weight)
            
            # Resolver conflitos
            result.conflicts_resolved = _resolve_data_conflicts(result.merged_contract.data, contracts, conflict_resolution)
        
        return result
    
    func _merge_priority_max(contracts: Array, base_result: MergeResult) -> MergeResult:
        """Fusão por prioridade máxima (usa contrato com maior prioridade)."""
        var result: MergeResult = base_result
        
        # Encontrar contrato com maior prioridade
        var highest_priority_contract = null
        var highest_priority_score: float = -1.0
        
        for contract in contracts:
            var priority_score: float = _calculate_priority_score(contract)
            if priority_score > highest_priority_score:
                highest_priority_score = priority_score
                highest_priority_contract = contract
        
        if highest_priority_contract:
            result.merged_contract = _convert_to_merged_format(highest_priority_contract)
            result.merged_contract.merge_strategy = merge_strategy
            result.merge_confidence = highest_priority_contract.confidence
        
        return result
    
    func _merge_safety_first(contracts: Array, base_result: MergeResult) -> MergeResult:
        """Fusão priorizando segurança."""
        var result: MergeResult = base_result
        
        # Filtrar contratos com flags de segurança
        var safety_contracts: Array = []
        for contract in contracts:
            if not contract.safety_flags.is_empty():
                safety_contracts.append(contract)
        
        # Se houver contratos com segurança, usar apenas eles
        if not safety_contracts.is_empty():
            # Usar média ponderada entre contratos seguros
            result = _merge_weighted_average(safety_contracts, result)
            result.merged_contract.safety_first = true
        else:
            # Caso contrário, usar contrato mais conservador
            result = _merge_most_conservative(contracts, result)
        
        return result
    
    func _merge_consensus(contracts: Array, base_result: MergeResult) -> MergeResult:
        """Fusão por consenso entre contratos."""
        var result: MergeResult = base_result
        
        # Verificar se temos contratos suficientes para consenso
        if contracts.size() < min_contracts_for_consensus:
            # Não há contratos suficientes, usar média ponderada
            return _merge_weighted_average(contracts, result)
        
        # Agrupar contratos por similaridade
        var clusters: Array = _cluster_contracts_by_similarity(contracts)
        
        # Encontrar maior cluster
        var largest_cluster: Array = []
        for cluster in clusters:
            if cluster.size() > largest_cluster.size():
                largest_cluster = cluster
        
        # Verificar se o maior cluster atinge o limiar de consenso
        var consensus_ratio: float = float(largest_cluster.size()) / float(contracts.size())
        if consensus_ratio >= consensus_threshold:
            # Usar contratos do cluster de consenso
            result = _merge_weighted_average(largest_cluster, result)
            result.merged_contract.consensus_achieved = true
            result.merged_contract.consensus_ratio = consensus_ratio
        else:
            # Sem consenso, usar estratégia de segurança
            result = _merge_safety_first(contracts, result)
            result.merged_contract.consensus_achieved = false
            result.merged_contract.consensus_ratio = consensus_ratio
        
        return result
    
    func _merge_most_conservative(contracts: Array, base_result: MergeResult) -> MergeResult:
        """Fusão usando os valores mais conservadores (mais seguros)."""
        var result: MergeResult = base_result
        
        # Começar com valores extremos
        var conservative_data: Dictionary = {}
        
        # Para cada campo numérico, usar o valor mais conservador
        # (menor compressão, menor influência, etc.)
        for contract in contracts:
            for key in contract.data.keys():
                var value = contract.data[key]
                
                if typeof(value) == TYPE_FLOAT:
                    if not conservative_data.has(key):
                        conservative_data[key] = value
                    else:
                        # Para campos de segurança, usar o valor mais conservador
                        if key.contains("max") or key.contains("limit"):
                            # Para limites máximos, usar o menor valor
                            conservative_data[key] = min(conservative_data[key], value)
                        elif key.contains("min"):
                            # Para limites mínimos, usar o maior valor
                            conservative_data[key] = max(conservative_data[key], value)
                        elif key.contains("compression") or key.contains("penetration"):
                            # Para compressão/penetração, usar o menor valor
                            conservative_data[key] = min(conservative_data[key], value)
                        else:
                            # Padrão: usar média
                            conservative_data[key] = (conservative_data[key] + value) / 2.0
        
        # Usar contrato com maior autoridade como base
        var highest_auth_contract = null
        var highest_auth: int = -1
        
        for contract in contracts:
            if contract.authority > highest_auth:
                highest_auth = contract.authority
                highest_auth_contract = contract
        
        if highest_auth_contract:
            result.merged_contract = _convert_to_merged_format(highest_auth_contract)
            result.merged_contract.data = conservative_data
            result.merged_contract.conservative_merge = true
        
        return result
    
    func _calculate_contract_weight(contract) -> float:
        """Calcula peso total de um contrato para fusão."""
        var mode_weight: float = mode_weights.get(contract.mode, 0.5)
        var authority_weight: float = authority_weights.get(contract.authority, 0.5)
        var confidence_weight: float = contract.confidence
        
        # Aumentar peso se tiver flags de segurança
        var safety_multiplier: float = 1.0
        if not contract.safety_flags.is_empty():
            safety_multiplier = safety_priority_multiplier
        
        # Combinação ponderada
        var weight: float = (mode_weight * 0.4 + authority_weight * 0.3 + confidence_weight * 0.3) * safety_multiplier
        return max(weight, 0.01)  # Peso mínimo
    
    func _calculate_priority_score(contract) -> float:
        """Calcula pontuação de prioridade para um contrato."""
        var mode_score: float = mode_weights.get(contract.mode, 0.5)
        var authority_score: float = authority_weights.get(contract.authority, 0.5)
        var safety_score: float = 1.0 if not contract.safety_flags.is_empty() else 0.5
        
        return mode_score * authority_score * safety_score * contract.confidence
    
    func _cluster_contracts_by_similarity(contracts: Array, similarity_threshold: float = 0.8) -> Array:
        """Agrupa contratos por similaridade."""
        var clusters: Array = []
        var assigned: Array = []  # Índices de contratos já atribuídos
        
        for i in range(contracts.size()):
            if assigned.has(i):
                continue
            
            # Criar novo cluster com este contrato
            var cluster: Array = [contracts[i]]
            assigned.append(i)
            
            # Encontrar contratos similares
            for j in range(i + 1, contracts.size()):
                if assigned.has(j):
                    continue
                
                var similarity: float = _calculate_contract_similarity(contracts[i], contracts[j])
                if similarity >= similarity_threshold:
                    cluster.append(contracts[j])
                    assigned.append(j)
            
            clusters.append(cluster)
        
        return clusters
    
    func _calculate_contract_similarity(contract1, contract2) -> float:
        """Calcula similaridade entre dois contratos."""
        # Similaridade de modo e autoridade
        var mode_similarity: float = 1.0 if contract1.mode == contract2.mode else 0.0
        var authority_similarity: float = 1.0 - abs(contract1.authority - contract2.authority) / 4.0
        
        # Similaridade de dados (para campos numéricos comuns)
        var data_similarity: float = 0.0
        var common_keys: int = 0
        
        for key in contract1.data.keys():
            if contract2.data.has(key):
                var value1 = contract1.data[key]
                var value2 = contract2.data[key]
                
                if typeof(value1) == TYPE_FLOAT and typeof(value2) == TYPE_FLOAT:
                    data_similarity += 1.0 - min(abs(value1 - value2), 1.0)
                    common_keys += 1
        
        if common_keys > 0:
            data_similarity /= common_keys
        else:
            data_similarity = 0.5  # Valor padrão se não houver chaves comuns
        
        # Média ponderada
        return (mode_similarity * 0.3 + authority_similarity * 0.3 + data_similarity * 0.4)
    
    func _merge_data_weighted(data_accumulators: Dictionary, total_weight: float) -> Dictionary:
        """Funde dados usando pesos acumulados."""
        var merged_data: Dictionary = {}
        
        for key in data_accumulators.keys():
            var accum = data_accumulators[key]
            if accum.weight > 0:
                var value = accum.sum / accum.weight
                
                # Reconstruir vetores se necessário
                if key.ends_with("_x"):
                    var base_key = key.substr(0, key.length() - 2)
                    var x = value
                    var y = data_accumulators.get(base_key + "_y", {"sum": 0.0, "weight": 0.0})
                    var z = data_accumulators.get(base_key + "_z", {"sum": 0.0, "weight": 0.0})
                    
                    if y.weight > 0 and z.weight > 0:
                        y = y.sum / y.weight
                        z = z.sum / z.weight
                        merged_data[base_key] = Vector3(x, y, z)
                elif not key.ends_with("_y") and not key.ends_with("_z"):
                    # Campo escalar regular
                    merged_data[key] = value
        
        return merged_data
    
    func _resolve_data_conflicts(data: Dictionary, contracts: Array, resolution_mode: int) -> int:
        """Resolve conflitos em dados fundidos."""
        var conflicts_resolved: int = 0
        
        for key in data.keys():
            var values: Array = []
            
            # Coletar todos os valores para este campo
            for contract in contracts:
                if contract.data.has(key):
                    values.append(contract.data[key])
            
            if values.size() <= 1:
                continue
            
            # Verificar se há conflito (valores significativamente diferentes)
            if _has_conflict(values):
                conflicts_resolved += 1
                
                match resolution_mode:
                    ConflictResolution.RESOLUTION_SAFETY:
                        data[key] = _resolve_for_safety(key, values)
                    ConflictResolution.RESOLUTION_CONSERVATIVE:
                        data[key] = _resolve_conservatively(key, values)
                    ConflictResolution.RESOLUTION_HIGHEST_CONFIDENCE:
                        data[key] = _resolve_highest_confidence(key, values, contracts)
                    _:  # RESOLUTION_AVERAGE
                        # Já é a média, não fazer nada
                        pass
        
        return conflicts_resolved
    
    func _has_conflict(values: Array, threshold: float = 0.1) -> bool:
        """Verifica se há conflito entre valores."""
        if values.size() < 2:
            return false
        
        var first_value = values[0]
        if typeof(first_value) != TYPE_FLOAT:
            return false  # Apenas verificar números por enquanto
        
        for i in range(1, values.size()):
            if abs(values[i] - first_value) > threshold:
                return true
        
        return false
    
    func _resolve_for_safety(key: String, values: Array) -> float:
        """Resolve conflito a favor da segurança."""
        if key.contains("max") or key.contains("limit"):
            # Para limites máximos, usar o menor valor (mais seguro)
            return values.min()
        elif key.contains("min"):
            # Para limites mínimos, usar o maior valor (mais seguro)
            return values.max()
        elif key.contains("compression") or key.contains("penetration"):
            # Para compressão/penetração, usar o menor valor (mais seguro)
            return values.min()
        else:
            # Padrão: usar média
            return values.reduce(func(a, b): return a + b) / values.size()
    
    func _resolve_conservatively(key: String, values: Array) -> float:
        """Resolve conflito conservadoramente."""
        # Similar à resolução de segurança, mas mais ampla
        if key.contains("compression") or key.contains("penetration") or key.contains("influence"):
            return values.min()
        else:
            return values.reduce(func(a, b): return a + b) / values.size()
    
    func _resolve_highest_confidence(key: String, values: Array, contracts: Array) -> float:
        """Resolve conflito usando valor do contrato com maior confiança."""
        var highest_confidence: float = -1.0
        var best_value = values[0]
        
        for i in range(contracts.size()):
            if contracts[i].confidence > highest_confidence and contracts[i].data.has(key):
                highest_confidence = contracts[i].confidence
                best_value = contracts[i].data[key]
        
        return best_value
    
    func _merge_safety_flags(contracts: Array) -> Array[String]:
        """Combina flags de segurança de todos os contratos."""
        var all_flags: Array[String] = []
        
        for contract in contracts:
            for flag in contract.safety_flags:
                if not all_flags.has(flag):
                    all_flags.append(flag)
        
        return all_flags
    
    func _calculate_merge_confidence(contracts: Array, conflicts_resolved: int) -> float:
        """Calcula confiança do resultado da fusão."""
        if contracts.is_empty():
            return 0.0
        
        # Confiança média dos contratos
        var total_confidence: float = 0.0
        for contract in contracts:
            total_confidence += contract.confidence
        
        var avg_confidence: float = total_confidence / contracts.size()
        
        # Penalizar por conflitos resolvidos
        var conflict_penalty: float = 0.1 * conflicts_resolved
        
        # Bonificação por consenso (se aplicável)
        var consensus_bonus: float = 0.0
        if contracts.size() >= min_contracts_for_consensus:
            var clusters: Array = _cluster_contracts_by_similarity(contracts)
            var largest_cluster_size: int = 0
            for cluster in clusters:
                largest_cluster_size = max(largest_cluster_size, cluster.size())
            
            var consensus_ratio: float = float(largest_cluster_size) / float(contracts.size())
            if consensus_ratio >= consensus_threshold:
                consensus_bonus = 0.2
        
        return clamp(avg_confidence - conflict_penalty + consensus_bonus, 0.0, 1.0)
    
    func _filter_valid_contracts(contracts: Array) -> Array:
        """Filtra contratos válidos para fusão."""
        var valid: Array = []
        
        for contract in contracts:
            # Verificar se o contrato tem método is_valid()
            if contract.has_method("is_valid"):
                if contract.is_valid():
                    valid.append(contract)
            else:
                # Assumir válido se não tiver método
                valid.append(contract)
        
        return valid
    
    func _convert_to_merged_format(contract) -> Dictionary:
        """Converte um contrato para o formato fundido."""
        return {
            "mode": contract.mode,
            "authority": contract.authority,
            "confidence": contract.confidence,
            "influence_weight": contract.influence_weight,
            "safety_flags": contract.safety_flags.duplicate(),
            "data": contract.data.duplicate(),
            "timestamp": contract.timestamp,
            "is_merged": false,  # Este não é fundido, é original
            "merge_strategy": -1,
            "source_count": 1
        }
    
    func _create_neutral_contract() -> Dictionary:
        """Cria um contrato neutro para casos de falha."""
        return {
            "mode": 0,  # MODE_CLAMP
            "authority": 0,  # AUTHORITY_NONE
            "confidence": 0.1,
            "influence_weight": 0.1,
            "safety_flags": ["neutral_fallback", "merge_failed"],
            "data": {
                "compression": 0.0,
                "normal": Vector3.UP,
                "contact_width": 0.0
            },
            "timestamp": Time.get_ticks_msec() / 1000.0,
            "is_merged": true,
            "merge_strategy": merge_strategy,
            "source_count": 0
        }
    
    func _extract_source_ids(contracts: Array) -> Array:
        """Extrai IDs de origem dos contratos."""
        var ids: Array = []
        for contract in contracts:
            if contract.has("source_id"):
                ids.append(contract.source_id)
            else:
                ids.append(str(contract.hash()))
        return ids
    
    func _get_key_with_max_weight(weight_dict: Dictionary):
        """Retorna a chave com maior peso em um dicionário."""
        var max_key = null
        var max_weight: float = -1.0
        
        for key in weight_dict.keys():
            if weight_dict[key] > max_weight:
                max_weight = weight_dict[key]
                max_key = key
        
        return max_key
    
    func _add_to_history(result: MergeResult, source_contracts: Array) -> void:
        """Adiciona fusão ao histórico."""
        var history_entry: Dictionary = {
            "timestamp": Time.get_ticks_msec() / 1000.0,
            "source_count": source_contracts.size(),
            "merged_confidence": result.merge_confidence,
            "conflicts_resolved": result.conflicts_resolved,
            "strategy": merge_strategy,
            "was_trivial": result.was_trivial
        }
        
        merge_history.append(history_entry)
        
        # Manter histórico dentro do limite
        if merge_history.size() > max_history_size:
            merge_history.remove_at(0)

# Sistema principal do fusor
signal contracts_merged(result: MergeResult)
signal merge_conflict_detected(conflicts: int, total_contracts: int)
signal merge_strategy_changed(old_strategy: int, new_strategy: int)

var _merger_instances: Dictionary = {}  # ID do dono -> ContractMergerInstance
var _default_merger: ContractMergerInstance
var _enabled: bool = true

@export_group("Merge Settings")
@export var default_merge_strategy: int = MergeStrategy.STRATEGY_WEIGHTED_AVERAGE
@export var default_conflict_resolution: int = ConflictResolution.RESOLUTION_SAFETY

@export_group("Consensus Settings")
@export_range(2, 10) var default_min_consensus: int = 2
@export_range(0.5, 1.0, 0.05) var default_consensus_threshold: float = 0.7

@export_group("Weights")
@export var enable_safety_priority: bool = true
@export_range(1.0, 5.0, 0.1) var safety_priority_strength: float = 2.0

func _ready() -> void:
    """Inicializa o sistema de fusão."""
    _default_merger = ContractMergerInstance.new()
    _default_merger.merge_strategy = default_merge_strategy
    _default_merger.conflict_resolution = default_conflict_resolution
    _default_merger.min_contracts_for_consensus = default_min_consensus
    _default_merger.consensus_threshold = default_consensus_threshold
    
    if enable_safety_priority:
        _default_merger.safety_priority_multiplier = safety_priority_strength
    
    _validate_configuration()

func merge_contracts_for_owner(owner_id: String, contracts: Array) -> MergeResult:
    """Funde contratos para um dono específico."""
    if not _enabled or contracts.is_empty():
        var result: MergeResult = MergeResult.new()
        result.merged_contract = _default_merger._create_neutral_contract()
        return result
    
    var merger: ContractMergerInstance = _get_or_create_merger(owner_id)
    var result: MergeResult = merger.merge_contracts(contracts)
    
    # Emitir sinais
    contracts_merged.emit(result)
    
    if result.conflicts_resolved > 0:
        merge_conflict_detected.emit(result.conflicts_resolved, contracts.size())
    
    return result

func get_merger_for_owner(owner_id: String) -> ContractMergerInstance:
    """Obtém ou cria um fusor para o dono."""
    if not _merger_instances.has(owner_id):
        _merger_instances[owner_id] = _create_merger_instance()
    
    return _merger_instances[owner_id]

func set_merge_strategy_for_owner(owner_id: String, strategy: int) -> void:
    """Define estratégia de fusão para um dono."""
    var merger: ContractMergerInstance = _get_or_create_merger(owner_id)
    var old_strategy: int = merger.merge_strategy
    merger.merge_strategy = strategy
    
    merge_strategy_changed.emit(old_strategy, strategy)

func set_conflict_resolution_for_owner(owner_id: String, resolution: int) -> void:
    """Define resolução de conflitos para um dono."""
    var merger: ContractMergerInstance = _get_or_create_merger(owner_id)
    merger.conflict_resolution = resolution

func get_merge_history_for_owner(owner_id: String, max_entries: int = 50) -> Array[Dictionary]:
    """Retorna histórico de fusões para um dono."""
    var merger: ContractMergerInstance = _merger_instances.get(owner_id)
    if not merger:
        return []
    
    var history: Array[Dictionary] = merger.merge_history.duplicate()
    if history.size() > max_entries:
        history = history.slice(history.size() - max_entries, history.size() - 1)
    
    return history

func get_merge_statistics_for_owner(owner_id: String) -> Dictionary:
    """Retorna estatísticas de fusão para um dono."""
    var merger: ContractMergerInstance = _merger_instances.get(owner_id)
    if not merger:
        return {"error": "no_merger_found"}
    
    var history: Array[Dictionary] = merger.merge_history
    if history.is_empty():
        return {"total_merges": 0}
    
    var total_merges: int = history.size()
    var total_contracts: int = 0
    var total_conflicts: int = 0
    var avg_confidence: float = 0.0
    
    for entry in history:
        total_contracts += entry.get("source_count", 0)
        total_conflicts += entry.get("conflicts_resolved", 0)
        avg_confidence += entry.get("merged_confidence", 0.0)
    
    avg_confidence /= total_merges if total_merges > 0 else 1.0
    
    return {
        "total_merges": total_merges,
        "avg_contracts_per_merge": float(total_contracts) / float(total_merges) if total_merges > 0 else 0.0,
        "avg_conflicts_per_merge": float(total_conflicts) / float(total_merges) if total_merges > 0 else 0.0,
        "avg_merge_confidence": avg_confidence,
        "current_strategy": merger.merge_strategy,
        "current_resolution": merger.conflict_resolution
    }

func _get_or_create_merger(owner_id: String) -> ContractMergerInstance:
    """Obtém ou cria um fusor para o dono."""
    if not _merger_instances.has(owner_id):
        _merger_instances[owner_id] = _create_merger_instance()
    
    return _merger_instances[owner_id]

func _create_merger_instance() -> ContractMergerInstance:
    """Cria uma nova instância do fusor."""
    var instance: ContractMergerInstance = ContractMergerInstance.new()
    instance.merge_strategy = default_merge_strategy
    instance.conflict_resolution = default_conflict_resolution
    instance.min_contracts_for_consensus = default_min_consensus
    instance.consensus_threshold = default_consensus_threshold
    
    if enable_safety_priority:
        instance.safety_priority_multiplier = safety_priority_strength
    
    return instance

func _validate_configuration() -> void:
    """Valida configuração do sistema."""
    assert(default_min_consensus >= 2, "Mínimo para consenso deve ser pelo menos 2")
    assert(default_consensus_threshold >= 0.5 and default_consensus_threshold <= 1.0, 
           "Limiar de consenso deve estar entre 0.5 e 1.0")
    assert(safety_priority_strength >= 1.0, "Força da prioridade de segurança deve ser >= 1.0")

# Funções públicas para integração
func set_enabled(enabled: bool) -> void:
    """Habilita ou desabilita o sistema de fusão."""
    _enabled = enabled

func is_enabled() -> bool:
    """Retorna se o sistema está habilitado."""
    return _enabled

func clear_owner_history(owner_id: String) -> void:
    """Limpa histórico de fusões de um dono."""
    var merger: ContractMergerInstance = _merger_instances.get(owner_id)
    if merger:
        merger.merge_history.clear()

func get_all_owner_ids() -> Array[String]:
    """Retorna IDs de todos os donos com fusores ativos."""
    return _merger_instances.keys()