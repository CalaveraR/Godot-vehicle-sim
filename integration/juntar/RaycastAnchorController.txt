# RaycastAnchorHybrid.gd
# Node3D principal que orquestra os módulos
class_name RaycastAnchorController extends Node3D

@export_group("Detection Philosophy")
@export var raycasts_as_optimization: bool = true
@export var raycasts_never_primary: bool = true
@export_range(0.0, 1.0, 0.05) var raycast_confidence_decay: float = 0.8

@export_group("Geometry Settings")
@export_range(1, 13, 1) var raycast_count: int = 5
@export var tire_width: float = 0.205
@export var tire_radius: float = 0.33
@export var max_suspension_travel: float = 0.25
@export var ray_origin_height: float = 0.05
@export var ray_length: float = 0.35

@export_group("Performance Settings")
@export var raycast_update_rate: float = 60.0
@export var enable_predictive_raycasting: bool = true
@export var max_prediction_distance: float = 0.1

@export_group("Extended Metrics")
@export var raycast_compute_extended_metrics: bool = false
@export var enable_temporal_dynamics: bool = true

@export_group("Advanced Contract System")
@export var enable_rate_limiting: bool = true
@export var max_contracts_per_second: float = 15.0
@export var min_contract_delta: float = 0.05
@export var debug_visualization_enabled: bool = false

@export_group("Contract Settings")
@export var enable_contract_merging: bool = true
@export var merge_prioritize_safety: bool = true
@export var allow_multiple_influence_sources: bool = false

@export var ground_collision_mask: int = 1

# Módulos
var _geometry_engine: GeometryEngine
var _influence_broker: InfluenceBroker
var _debug_visualizer: ContractDebugVisualizer

# Variáveis internas
var _time_since_last_update: float = 0.0
var _last_contact_state: bool = false
var _last_update_time: float = 0.0

# Sinais (mantidos da implementação original)
signal raycast_contact_started
signal raycast_contact_ended
signal raycast_anchor_updated(anchor_data: Dictionary)
signal sudden_impact_detected(compression_velocity: float)
signal contact_loss_detected
signal influence_contract_generated(contract_data: Dictionary)
signal influence_contract_applied(original_state: Dictionary, modified_state: Dictionary)
signal neutral_contract_created(contract_data: Dictionary)
signal contract_rate_limited
signal contract_merged(source_count: int)

func _ready():
    _validate_parameters()
    
    # Instanciar e configurar módulos
    _initialize_modules()
    
    # Configurar sinais
    _setup_module_connections()
    
    _last_update_time = Time.get_ticks_msec() / 1000.0

func _initialize_modules() -> void:
    # Geometry Engine
    _geometry_engine = GeometryEngine.new()
    _geometry_engine.configure(
        raycast_count,
        tire_width,
        max_suspension_travel,
        ray_origin_height,
        ray_length,
        ground_collision_mask,
        enable_temporal_dynamics,
        raycast_compute_extended_metrics
    )
    _geometry_engine.temporal_data_calculated.connect(_on_temporal_data_calculated)
    _geometry_engine.dynamic_event_detected.connect(_on_dynamic_event_detected)
    
    # Influence Broker
    _influence_broker = InfluenceBroker.new()
    _influence_broker.configure(
        raycasts_as_optimization,
        raycasts_never_primary,
        tire_width,
        max_suspension_travel,
        enable_rate_limiting,
        max_contracts_per_second,
        min_contract_delta,
        enable_contract_merging
    )
    
    # Debug Visualizer
    _debug_visualizer = ContractDebugVisualizer.new()
    add_child(_debug_visualizer)
    _debug_visualizer.configure(
        tire_radius,
        tire_width,
        max_suspension_travel,
        raycast_count,
        debug_visualization_enabled
    )
    
    if debug_visualization_enabled:
        _debug_visualizer.enable_visualization()

func _setup_module_connections() -> void:
    # Conectar sinais do GeometryEngine
    _geometry_engine.temporal_data_calculated.connect(_on_temporal_data_calculated)
    _geometry_engine.dynamic_event_detected.connect(_on_dynamic_event_detected)

func _validate_parameters() -> void:
    if raycast_count < 1:
        raycast_count = 1
    
    if ray_length <= 0:
        ray_length = 0.35

func update_raycast_anchor(suspension_data: Dictionary, delta: float) -> Dictionary:
    _time_since_last_update += delta
    var update_interval = 1.0 / raycast_update_rate
    
    if _time_since_last_update < update_interval:
        var last_results = _geometry_engine.get_last_results()
        if not last_results or not last_results.has_contact:
            return _geometry_engine.get_continuous_fallback_anchor()
    
    _time_since_last_update = 0.0
    
    # Atualizar espaço físico
    _geometry_engine.set_space_state(get_world_3d().direct_space_state)
    
    # Executar raycasts via GeometryEngine
    var result = _geometry_engine.update_raycast_anchor(
        global_transform,
        suspension_data,
        delta
    )
    
    # Atualizar visualização de debug
    if debug_visualization_enabled:
        var current_time = Time.get_ticks_msec() / 1000.0
        _debug_visualizer.update_debug_drawing(
            result,
            global_transform,
            current_time
        )
    
    # Emitir sinais de contato
    _emit_contact_signals(result.has_contact)
    
    # Emitir sinal de atualização
    emit_signal("raycast_anchor_updated", _convert_result_to_dict(result))
    
    return _convert_result_to_dict(result)

func _on_temporal_data_calculated(temporal_data: Dictionary) -> void:
    # Emitir sinal de impacto súbito se detectado
    var compression_velocity = temporal_data.get("compression_velocity", 0.0)
    if absf(compression_velocity) > 2.0:
        emit_signal("sudden_impact_detected", compression_velocity)

func _on_dynamic_event_detected(event_type: String, data: Dictionary) -> void:
    match event_type:
        "contact_loss":
            emit_signal("contact_loss_detected")
        "normal_variation":
            print("Aviso: Variação súbita na normal do terreno")

func _emit_contact_signals(has_contact: bool) -> void:
    if has_contact and not _last_contact_state:
        emit_signal("raycast_contact_started")
    elif not has_contact and _last_contact_state:
        emit_signal("raycast_contact_ended")
    
    _last_contact_state = has_contact

func _convert_result_to_dict(result: GeometryEngine.RaycastAnchorResult) -> Dictionary:
    return {
        "has_contact": result.has_contact,
        "avg_normal": result.avg_normal,
        "avg_contact_point": result.avg_contact_point,
        "compression": result.compression,
        "compression_normalized": result.compression_normalized,
        "max_compression": result.max_compression,
        "contact_patch_width": result.contact_patch_width,
        "confidence": result.confidence,
        "active_ray_count": result.active_ray_count,
        "ray_contacts": result.ray_contacts,
        "contact_patch_area": result.contact_patch_area if raycast_compute_extended_metrics else 0.0,
        "penetration_depth": result.penetration_depth if raycast_compute_extended_metrics else 0.0,
        "stability_score": result.stability_score if raycast_compute_extended_metrics else 0.0,
        "physical_constraints": result.physical_constraints,
        "temporal_data": result.temporal_data
    }

# Métodos públicos (interface compatível com original)
func evaluate_raycast_influence(shader_state: Dictionary) -> Dictionary:
    var raycast_constraints = _geometry_engine.get_physical_constraints()
    var raycast_data = _geometry_engine.get_last_results()
    
    return _influence_broker.evaluate_raycast_influence(
        shader_state,
        raycast_constraints,
        raycast_data
    )

func generate_influence_contract(shader_state: Dictionary) -> InfluenceBroker.RaycastInfluenceContract:
    var raycast_constraints = _geometry_engine.get_physical_constraints()
    var raycast_data = _geometry_engine.get_last_results()
    
    var contract = _influence_broker.generate_influence_contract(
        shader_state,
        raycast_constraints,
        raycast_data
    )
    
    emit_signal("influence_contract_generated", contract.to_dictionary())
    
    return contract

func apply_raycast_influence(
    shader_state: Dictionary,
    influence_contract: Dictionary
) -> Dictionary:
    var result = _influence_broker.apply_raycast_influence(shader_state, influence_contract)
    
    emit_signal("influence_contract_applied", shader_state, result)
    
    return result

func apply_influence_contract(
    shader_state: Dictionary,
    contract: Dictionary
) -> Dictionary:
    return _influence_broker.apply_influence_contract(shader_state, contract)

func create_neutral_contract_from_raycast(shader_state: Dictionary) -> Dictionary:
    var geometry_data = _geometry_engine.get_continuous_fallback_anchor()
    
    var contract = _influence_broker.create_neutral_contract_from_raycast(
        shader_state,
        geometry_data
    )
    
    # Registrar contrato no visualizador
    if debug_visualization_enabled:
        _debug_visualizer.record_contract(contract, shader_state)
    
    emit_signal("neutral_contract_created", contract)
    
    return contract

func process_multiple_influence_sources(
    shader_state: Dictionary,
    influence_sources: Array
) -> Dictionary:
    var raycast_geometry_data = _geometry_engine.get_continuous_fallback_anchor()
    
    var result = _influence_broker.process_multiple_influence_sources(
        shader_state,
        influence_sources,
        raycast_geometry_data
    )
    
    emit_signal("contract_merged", influence_sources.size())
    
    return result

func process_contact_with_neutral_contract(
    shader_state: Dictionary,
    suspension_data: Dictionary,
    delta: float
) -> Dictionary:
    # Atualizar raycasts
    var geometry_data_dict = update_raycast_anchor(suspension_data, delta)
    
    # Criar contrato neutro
    var contract = create_neutral_contract_from_raycast(shader_state)
    
    # Aplicar contrato
    var processed_state = apply_influence_contract(shader_state, contract)
    
    return processed_state

# Métodos de utilidade (mantidos para compatibilidade)
func suggest_shader_activation() -> Dictionary:
    var suggestions = {
        "active_regions": [],
        "confidence_factor": 0.0,
        "physical_constraints": _geometry_engine.get_physical_constraints(),
        "temporal_hints": {},
        "priority_blocks": []
    }
    
    var last_results = _geometry_engine.get_last_results()
    if not last_results or not last_results.has_contact:
        return suggestions
    
    suggestions["confidence_factor"] = last_results.confidence
    
    if enable_temporal_dynamics and last_results.temporal_data:
        suggestions["temporal_hints"] = {
            "compression_velocity": last_results.temporal_data.get("compression_velocity", 0.0),
            "suggested_response_time": _calculate_suggested_response_time()
        }
    
    for contact in last_results.ray_contacts:
        var local_pos = to_local(contact["position"])
        var region = {
            "center": local_pos,
            "radius": tire_width * 0.25,
            "priority": contact["compression_normalized"],
            "normal": contact["normal"],
            "max_penetration": minf(contact["compression"] * 1.5, max_suspension_travel)
        }
        suggestions["active_regions"].append(region)
        
        if contact["compression_normalized"] > 0.3:
            suggestions["priority_blocks"].append({
                "world_position": contact["position"],
                "size": Vector2(0.1, 0.1),
                "expected_penetration": contact["compression"]
            })
    
    return suggestions

func _calculate_suggested_response_time() -> float:
    if not enable_temporal_dynamics:
        return 0.01
    
    var last_results = _geometry_engine.get_last_results()
    if not last_results or not last_results.temporal_data:
        return 0.01
    
    var velocity = absf(last_results.temporal_data.get("compression_velocity", 0.0))
    if velocity < 0.1:
        return 0.02
    elif velocity < 1.0:
        return 0.01
    else:
        return 0.005

func get_continuous_fallback_anchor() -> Dictionary:
    return _geometry_engine.get_continuous_fallback_anchor()

func get_physical_constraints() -> Dictionary:
    return _geometry_engine.get_physical_constraints()

func is_physically_plausible(shader_penetration: float, contact_width: float) -> bool:
    return _geometry_engine.is_physically_plausible(shader_penetration, contact_width)

func get_terrain_reference_plane() -> Dictionary:
    var last_results = _geometry_engine.get_last_results()
    if last_results and last_results.has_contact:
        return {
            "point": last_results.avg_contact_point,
            "normal": last_results.avg_normal,
            "confidence": last_results.confidence
        }
    
    return {
        "point": global_transform.origin,
        "normal": Vector3.UP,
        "confidence": 0.0
    }

# Métodos de debug e diagnóstico
func get_system_diagnostics() -> Dictionary:
    return {
        "basic_system": {
            "raycast_count": raycast_count,
            "active_rays": _geometry_engine.get_last_results().active_ray_count if _geometry_engine.get_last_results() else 0,
            "has_contact": _geometry_engine.get_last_results().has_contact if _geometry_engine.get_last_results() else false,
            "confidence": _geometry_engine.get_last_results().confidence if _geometry_engine.get_last_results() else 0.0
        },
        "rate_limiter": _influence_broker.get_rate_limiter_stats(),
        "debug_visualizer": _debug_visualizer.get_debug_stats() if debug_visualization_enabled else {"status": "inativo"},
        "philosophy_status": validate_philosophy()
    }

func export_debug_data() -> Dictionary:
    return {
        "system_info": {
            "class": "RaycastAnchorHybrid",
            "timestamp": Time.get_ticks_msec(),
            "version": "4.0_modular"
        },
        "timeline_data": _debug_visualizer.export_timeline_data() if debug_visualization_enabled else {},
        "current_state": {
            "raycast_data": _convert_result_to_dict(_geometry_engine.get_last_results()) if _geometry_engine.get_last_results() else {},
            "rate_limiter": _influence_broker.get_rate_limiter_stats()
        },
        "configuration": {
            "raycast_count": raycast_count,
            "tire_width": tire_width,
            "max_suspension_travel": max_suspension_travel,
            "raycast_update_rate": raycast_update_rate,
            "raycasts_never_primary": raycasts_never_primary,
            "enable_rate_limiting": enable_rate_limiting,
            "enable_contract_merging": enable_contract_merging,
            "debug_visualization_enabled": debug_visualization_enabled
        }
    }

func toggle_debug_visualization() -> void:
    if debug_visualization_enabled:
        debug_visualization_enabled = false
        _debug_visualizer.disable_visualization()
    else:
        debug_visualization_enabled = true
        _debug_visualizer.enable_visualization()

# Métodos de teste
func test_influence_contract() -> bool:
    var test_shader_state = {
        "confidence": 0.9,
        "avg_penetration": 0.15,
        "contact_width": 0.18,
        "timestamp": Time.get_ticks_msec()
    }
    
    var contract = generate_influence_contract(test_shader_state)
    
    if not contract.is_valid():
        return false
    
    var influenced_state = apply_raycast_influence(test_shader_state, contract.to_dictionary())
    
    var violations = []
    
    if test_shader_state.has("normal") and influenced_state.has("normal"):
        if test_shader_state["normal"] != influenced_state["normal"]:
            violations.append("Normal alterada")
    
    var max_pen = contract.limits.get("max_penetration", INF)
    if influenced_state.get("avg_penetration", 0.0) > max_pen * 1.01:
        violations.append("Penetração excede limite físico")
    
    return violations.size() == 0

func test_neutral_contract_system() -> bool:
    var test_shader_state = {
        "confidence": 0.8,
        "avg_penetration": 0.2,
        "contact_width": 0.25,
        "timestamp": Time.get_ticks_msec()
    }
    
    var contract = create_neutral_contract_from_raycast(test_shader_state)
    var result = apply_influence_contract(test_shader_state, contract)
    
    # Verificar neutralidade
    var is_neutral = true
    var result_str = JSON.stringify(result)
    
    if result_str.find("raycast") != -1:
        is_neutral = false
    
    if not result.has("contract_applied"):
        is_neutral = false
    elif result["contract_applied"].has("origin"):
        is_neutral = false
    
    # Verificar consistência
    var result2 = apply_influence_contract(test_shader_state, contract)
    if not _states_are_equivalent(result, result2):
        is_neutral = false
    
    return is_neutral

func _states_are_equivalent(a: Dictionary, b: Dictionary) -> bool:
    var keys = a.keys()
    for key in keys:
        if key == "timestamp" or key == "contract_applied":
            continue
        if a[key] != b[key]:
            return false
    return true

func validate_philosophy() -> bool:
    # Verificar que não há métodos de força
    if has_method("_calculate_force") or has_method("apply_forces"):
        return false
    return true

func validate_anchor_contract() -> bool:
    var errors = []
    
    if not raycasts_never_primary:
        errors.append("❌ Raycasts configurados como primários")
    
    if not has_method("get_physical_constraints"):
        errors.append("❌ Método get_physical_constraints não encontrado")
    
    if not has_method("get_continuous_fallback_anchor"):
        errors.append("❌ Método get_continuous_fallback_anchor não encontrado")
    
    if not has_signal("sudden_impact_detected"):
        errors.append("❌ Sinal sudden_impact_detected não encontrado")
    
    if errors.size() ==