# res://core/solver/BrushModelSolver.gd
class_name BrushModelSolver
extends RefCounted

# Parâmetros do modelo de brush (valores padrão)
var enable_brush_model: bool = true
var brush_stiffness: float = 2.5e6      # N/m
var lateral_stiffness: float = 2.0e6    # N/m
var friction_coefficient: float = 1.2
var peak_slip_ratio: float = 0.15
var peak_slip_angle: float = 0.1        # rad

var saturation_factor: float = 0.8
var post_peak_decay: float = 0.6
var recovery_speed: float = 2.0

var enable_aligning_torque: bool = true
var pneumatic_trail: float = 0.03        # metros
var aligning_stiffness: float = 500.0

# Estado interno
var _saturation_cache: Array[float] = []
var _last_forces: Dictionary = {}

# Inicializa o cache de saturação com base no número de amostras
func _initialize_cache(sample_count: int) -> void:
	_saturation_cache.resize(sample_count)
	_saturation_cache.fill(1.0)

# Resolve as forças para todas as amostras e retorna as forças totais
func solve(samples: Array[TireSample], patch: ContactPatch, patch_state: TirePatchStateGrid, delta: float) -> Dictionary:
	if samples.is_empty():
		return _empty_forces()
	
	# Garante que o cache tenha o tamanho adequado
	if _saturation_cache.size() != samples.size():
		_initialize_cache(samples.size())
	
	var processed_samples: Array = []
	
	for i in range(samples.size()):
		var sample: TireSample = samples[i]
		var processed = _process_sample(sample, patch_state, i)
		processed_samples.append(processed)
	
	var total_forces = _integrate_forces(processed_samples)
	_last_forces = total_forces.duplicate()
	return total_forces

# Processa uma única amostra aplicando o modelo de brush
func _process_sample(sample: TireSample, patch_state: TirePatchStateGrid, idx: int) -> Dictionary:
	var result = {
		"brush_force_long": 0.0,
		"brush_force_lat": 0.0,
		"aligning_torque": 0.0,
		"saturation": 1.0
	}
	
	if not enable_brush_model:
		# Modelo linear simples (fallback)
		result.brush_force_long = sample.slip_vector.x * brush_stiffness * sample.penetration
		result.brush_force_lat = sample.slip_vector.y * lateral_stiffness * sample.penetration
		return result
	
	# Obtém deflexão acumulada do patch_state (ou usa slip atual)
	var deflection = sample.slip_vector
	if patch_state:
		deflection = patch_state.get_deflection_at(sample.pos_x, sample.pos_y)
	
	# Forças elásticas (antes da saturação)
	var elastic_force_long = brush_stiffness * deflection.x
	var elastic_force_lat = lateral_stiffness * deflection.y
	
	# Saturação baseada no slip
	var slip_magnitude = deflection.length()
	var saturation = _calculate_saturation(slip_magnitude, idx)
	
	# Força máxima de atrito disponível
	var max_friction = friction_coefficient * sample.penetration * 1000.0  # N
	
	# Limita forças pela saturação/atrito
	elastic_force_long = clamp(elastic_force_long, -max_friction * saturation, max_friction * saturation)
	elastic_force_lat = clamp(elastic_force_lat, -max_friction * saturation, max_friction * saturation)
	
	# Decaimento pós-pico se em slip
	if sample.get("is_slipping", false):
		elastic_force_long *= post_peak_decay
		elastic_force_lat *= post_peak_decay
	
	# Momento auto-alinhante
	var aligning_torque = 0.0
	if enable_aligning_torque:
		aligning_torque = _calculate_aligning_torque(elastic_force_lat, deflection.y, sample)
	
	# Atualiza resultado
	result.brush_force_long = elastic_force_long
	result.brush_force_lat = elastic_force_lat
	result.aligning_torque = aligning_torque
	result.saturation = saturation
	
	# Atualiza cache de saturação para histerese
	_saturation_cache[idx] = saturation
	
	return result

# Calcula o fator de saturação (0 a 1) baseado na magnitude do slip
func _calculate_saturation(slip_magnitude: float, cell_idx: int) -> float:
	var normalized_slip = slip_magnitude / peak_slip_ratio
	var saturation = sin(atan(2.0 * normalized_slip)) * saturation_factor
	
	# Histerese: a saturação diminui mais lentamente do que aumenta
	if saturation < _saturation_cache[cell_idx]:
		saturation = lerp(_saturation_cache[cell_idx], saturation, recovery_speed * 0.01)
	
	return clamp(saturation, 0.0, 1.0)

# Calcula o torque auto-alinhante a partir da força lateral e ângulo de slip
func _calculate_aligning_torque(lateral_force: float, slip_angle: float, sample: TireSample) -> float:
	if not enable_aligning_torque:
		return 0.0
	
	# Pneumatic trail diminui com o aumento do ângulo de slip
	var effective_trail = pneumatic_trail * exp(-abs(slip_angle) * 10.0)
	
	# Momento devido à força lateral (auto-alinhamento)
	var aligning_moment = -lateral_force * effective_trail
	
	# Componente elástica adicional (rigidez torsional)
	var elastic_moment = -slip_angle * aligning_stiffness * sample.penetration
	
	return aligning_moment + elastic_moment

# Integra as forças de todas as amostras em um único dicionário de forças totais
func _integrate_forces(samples: Array) -> Dictionary:
	var total = {
		"Fx": 0.0,
		"Fy": 0.0,
		"Fz": 0.0,
		"Mz": 0.0
	}
	
	for s in samples:
		total.Fx += s.get("brush_force_long", 0.0)
		total.Fy += s.get("brush_force_lat", 0.0)
		total.Mz += s.get("aligning_torque", 0.0)
		
		# Força vertical proporcional à penetração (modelo simples)
		total.Fz += s.get("penetration", 0.0) * 1000.0  # N
	
	return total

# Retorna um dicionário com todas as forças zeradas
func _empty_forces() -> Dictionary:
	return {"Fx": 0.0, "Fy": 0.0, "Fz": 0.0, "Mz": 0.0}

# Retorna as últimas forças calculadas (útil para depuração)
func get_last_forces() -> Dictionary:
	return _last_forces.duplicate()