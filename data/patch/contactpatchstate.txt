# Representa√ß√£o estruturada do patch de contato do pneu com histerese
# Espa√ßo local da roda (para f√≠sica) + m√©tricas agregadas + mem√≥ria temporal
class_name ContactPatchstate

# --- Constantes de histerese ---
# NOTA: MAX_STORED_ENERGY √© uma unidade abstrata, n√£o Joules f√≠sicos
# Valor normalizado para facilitar ajuste e debug
const MAX_STORED_ENERGY := 10.0
const MIN_HYSTERESIS_FACTOR := 0.7
const HYSTERESIS_RECOVERY_FAST := 4.0
const HYSTERESIS_RECOVERY_SLOW := 0.8
const RESIDUAL_DECAY_RATE := 2.0
const ENERGY_THRESHOLD := 5.0
const SLIP_ENERGY_THRESHOLD := 0.1

# Constantes para micro-lag e efeitos direcionais
const SLIP_LAG_RATE := 8.0  # Taxa de lag exponencial do slip
const RESIDUAL_DIRECTIONAL_NOISE := 0.05  # Escala do ru√≠do direcional p√≥s-derrapagem
const CONFIDENCE_HYSTERESIS_MULTIPLIER := 0.5  # Confian√ßa m√≠nima para histerese

# --- Dados de entrada ---
var samples: Array[TireSample] = []

# --- Propriedades agregadas (espa√ßo local da roda) ---
var center_of_pressure_local: Vector3
var average_normal_local: Vector3  # J√° normalizada ‚Äî n√£o renormalizar no solver
var average_slip_local: Vector2
var lagged_slip_local: Vector2  # Slip com micro-lag para sensa√ß√£o de massa

# --- M√©tricas escalares ---
var total_contact_weight: float
var max_penetration: float
var patch_confidence: float

# --- Estado de histerese ---
# üîπ 1Ô∏è‚É£ Histerese simples do pneu
# stored_energy: acumula input (slip + penetra√ß√£o)
# recovery: decay exponencial baseado no n√≠vel de energia
var stored_energy: float = 0.0        # Energia acumulada (unidades abstratas)
var residual_energy: float = 0.0      # Energia residual ap√≥s transi√ß√µes bruscas
var hysteresis_factor: float = 1.0    # [0.7 .. 1.0] - fator de modula√ß√£o puro
var last_slip_magnitude: float = 0.0  # Para detectar transi√ß√µes r√°pidas

# --- Controle interno ---
var timestamp: float
var valid: bool = false
var contributing_samples: int = 0

# --- Inicializa√ß√£o ---
func _init(sample_array: Array[TireSample] = [], time: float = 0.0) -> void:
    """
    IMPORTANTE:
    Este patch √© somente leitura para o solver.
    Qualquer modifica√ß√£o exige recalculate() ou rebuild_from_samples().
    
    Histerese: o patch mant√©m mem√≥ria de esfor√ßos recentes para
    simular in√©rcia t√©rmica/mec√¢nica da borracha.
    
    NOTA: stored_energy √© unidade abstrata, n√£o f√≠sica.
    
    üîπ IMPLEMENTA√á√ïES-CHAVE:
    1. Histerese simples: stored_energy += input, stored_energy -= recovery * delta
    2. Mem√≥ria residual: residual_energy *= exp(-delta * decay_rate) (decay barato)
    3. Micro-lag no slip para sensa√ß√£o de massa
    4. Histerese modulada pela confian√ßa da superf√≠cie
    5. Ru√≠do direcional p√≥s-derrapagem
    6. Reset apenas por teleporte expl√≠cito
    """
    rebuild_from_samples(sample_array, time)

# --- M√©todos p√∫blicos de atualiza√ß√£o ---

func rebuild_from_samples(new_samples: Array[TireSample], time: float) -> void:
    """Reconstr√≥i completamente o patch a partir de novas amostras"""
    samples = new_samples
    timestamp = time
    _recalculate_aggregates()
    # Inicializa lagged_slip com o valor atual
    lagged_slip_local = average_slip_local

func recalculate() -> void:
    """Recalcula propriedades com as amostras atuais"""
    _recalculate_aggregates()

func update_hysteresis(delta: float, tire_load: float, tire_stiffness: float) -> void:
    """
    Atualiza o estado de histerese com base no contato atual
    delta: tempo desde √∫ltima atualiza√ß√£o
    tire_load: carga vertical atual no pneu
    tire_stiffness: rigidez vertical do pneu
    
    üîπ 1Ô∏è‚É£ Histerese simples do pneu:
    stored_energy += input (slip + penetra√ß√£o)
    stored_energy -= recovery * delta (decay exponencial)
    
    üîπ 2Ô∏è‚É£ Mem√≥ria de energia residual:
    residual_energy *= exp(-delta * decay_rate) (decay barato)
    """
    if not valid:
        # Sem contato: decaimento mais r√°pido
        stored_energy *= exp(-HYSTERESIS_RECOVERY_FAST * delta)
        residual_energy *= exp(-RESIDUAL_DECAY_RATE * delta)
        _update_hysteresis_factor()
        return
    
    var current_slip_magnitude = get_average_slip_magnitude()
    
    # üîπ 1Ô∏è‚É£ AC√öMULO (input) da histerese simples
    # TODO: Futuramente tornar threshold dependente da carga
    if current_slip_magnitude > SLIP_ENERGY_THRESHOLD:
        var slip_energy = current_slip_magnitude * tire_load * delta
        stored_energy += slip_energy  # INPUT: slip significativo
    
    # INPUT adicional por deforma√ß√£o (penetra√ß√£o)
    if max_penetration > 0.0:
        var deformation_energy = max_penetration * tire_stiffness * delta
        stored_energy += deformation_energy  # INPUT: deforma√ß√£o
    
    # üîπ 2Ô∏è‚É£ Mem√≥ria de energia residual (transi√ß√µes bruscas)
    var slip_change = abs(current_slip_magnitude - last_slip_magnitude)
    if slip_change > 0.2:  # Mudan√ßa brusca no slip
        residual_energy += slip_change * tire_load * 0.5  # INPUT residual
    
    # 4. Satura√ß√£o (MAX_STORED_ENERGY √© unidade abstrata)
    stored_energy = min(stored_energy, MAX_STORED_ENERGY)
    
    # üîπ 1Ô∏è‚É£ RECUPERA√á√ÉO (recovery) da histerese simples
    # Decay exponencial: stored_energy -= recovery * delta (impl√≠cito na multiplica√ß√£o)
    var decay_rate = HYSTERESIS_RECOVERY_SLOW if stored_energy > ENERGY_THRESHOLD else HYSTERESIS_RECOVERY_FAST
    stored_energy *= exp(-decay_rate * delta)  # RECOVERY: decay exponencial
    
    # üîπ 2Ô∏è‚É£ Decay da mem√≥ria residual (decay barato)
    residual_energy *= exp(-RESIDUAL_DECAY_RATE * delta)  # DECAY: residual_energy *= exp(-delta * decay_rate)
    
    # 6. Aplica micro-lag no slip para sensa√ß√£o de massa
    _apply_slip_lag(delta)
    
    # 7. Aplica ru√≠do direcional baseado na energia residual
    _apply_directional_noise()
    
    # 8. Atualiza fator de histerese (sem confian√ßa aqui)
    _update_hysteresis_factor()
    
    # 9. Guarda slip para pr√≥ximo frame
    last_slip_magnitude = current_slip_magnitude

func reset_hysteresis() -> void:
    """
    Reseta completamente o estado de histerese (ex: ap√≥s teleporte)
    AVISO: Chamar apenas em teleporte expl√≠cito para evitar popping
    """
    stored_energy = 0.0
    residual_energy = 0.0
    hysteresis_factor = 1.0
    last_slip_magnitude = 0.0
    lagged_slip_local = average_slip_local

# --- C√°lculo das propriedades do patch ---
func _recalculate_aggregates() -> void:
    valid = false
    
    if samples.is_empty():
        _reset_to_default()
        return

    var weighted_pos = Vector3.ZERO
    var weighted_normal = Vector3.ZERO
    var weighted_slip = Vector2.ZERO
    
    total_contact_weight = 0.0
    max_penetration = 0.0
    patch_confidence = 0.0
    contributing_samples = 0
    
    # Processa apenas amostras v√°lidas e com penetra√ß√£o positiva
    for sample in samples:
        if not sample.valid or sample.penetration <= 0.0:
            continue
            
        # Peso baseado em penetra√ß√£o e confian√ßa
        var sample_weight = sample.penetration * sample.confidence
        if sample_weight <= 0.0:
            continue
            
        # Soma ponderada no espa√ßo local da roda
        weighted_pos += sample.contact_pos_local * sample_weight
        weighted_normal += sample.contact_normal_local * sample_weight
        weighted_slip += sample.slip_vector * sample_weight
        
        total_contact_weight += sample_weight
        max_penetration = max(max_penetration, sample.penetration)
        patch_confidence += sample.confidence
        contributing_samples += 1
    
    # Verifica se h√° amostras contribuindo
    if total_contact_weight <= 0.0 or contributing_samples == 0:
        _reset_to_default()
        return
    
    # Calcula m√©dias ponderadas
    center_of_pressure_local = weighted_pos / total_contact_weight
    average_normal_local = (weighted_normal / total_contact_weight).normalized()
    average_slip_local = weighted_slip / total_contact_weight
    
    # Normaliza confian√ßa apenas entre amostras contribuintes
    patch_confidence /= float(contributing_samples)
    
    # Marca como v√°lido
    valid = true

# --- Efeitos de feeling (micro-lag e ru√≠do) ---
func _apply_slip_lag(delta: float) -> void:
    """
    Aplica micro-lag exponencial ao slip para sensa√ß√£o de massa na borracha.
    Barato e poderoso para feeling de in√©rcia.
    """
    if valid and average_slip_local.length_squared() > 0.0:
        var lag_weight = exp(-SLIP_LAG_RATE * delta)
        lagged_slip_local = lagged_slip_local.lerp(average_slip_local, lag_weight)
    else:
        lagged_slip_local = average_slip_local

func _apply_directional_noise() -> void:
    """
    Adiciona ru√≠do direcional baseado na energia residual.
    Cria volante "nervoso" p√≥s-derrapagem e sensa√ß√£o de carca√ßa torcida.
    """
    if valid and residual_energy > 0.0 and lagged_slip_local.length_squared() > 0.0:
        var directional_noise = (residual_energy / MAX_STORED_ENERGY) * RESIDUAL_DIRECTIONAL_NOISE
        var orthogonal_component = lagged_slip_local.orthogonal() * directional_noise
        lagged_slip_local += orthogonal_component

# --- C√°lculo do fator de histerese ---
func _update_hysteresis_factor() -> void:
    """
    Converte energia armazenada em fator de histerese [0.7..1.0].
    ATEN√á√ÉO: N√£o inclui patch_confidence aqui.
    
    üîπ Tradu√ß√£o direta da histerese simples para fator √∫til:
    stored_energy ‚Üí hysteresis_factor [0.7..1.0]
    """
    var total_energy = stored_energy + residual_energy * 0.3
    var normalized_energy = clamp(total_energy / MAX_STORED_ENERGY, 0.0, 1.0)
    
    # Curva de resposta: lenta para cair, r√°pida para subir
    hysteresis_factor = lerp(
        1.0,
        MIN_HYSTERESIS_FACTOR,
        sqrt(normalized_energy)  # sqrt para resposta n√£o-linear
    )

# --- Reset para estado padr√£o (para pooling) ---
func reset() -> void:
    """Reseta o patch para estado inicial (uso com pooling)"""
    samples.clear()
    timestamp = 0.0
    _reset_to_default()

func _reset_to_default() -> void:
    """Reset interno de valores para estado padr√£o"""
    center_of_pressure_local = Vector3.ZERO
    average_normal_local = Vector3.UP  # Normal padr√£o j√° normalizada
    average_slip_local = Vector2.ZERO
    lagged_slip_local = Vector2.ZERO
    
    total_contact_weight = 0.0
    max_penetration = 0.0
    patch_confidence = 0.0
    contributing_samples = 0
    valid = false
    
    # NOTA: histerese N√ÉO √© resetada aqui (mantida entre frames)
    # Teleporte expl√≠cito deve chamar reset_hysteresis()

# --- M√©todos utilit√°rios (para debug/visualiza√ß√£o) ---

func get_center_of_pressure_ws(tire_transform: Transform3D) -> Vector3:
    """Converte o centro de press√£o para world-space (apenas para debug)"""
    return tire_transform * center_of_pressure_local

func get_average_normal_ws(tire_transform: Transform3D) -> Vector3:
    """Converte a normal m√©dia para world-space (apenas para debug)"""
    return tire_transform.basis * average_normal_local

func get_average_slip_magnitude() -> float:
    """Retorna a magnitude do slip m√©dio (RAW, sem lag)"""
    return average_slip_local.length()

func get_lagged_slip_magnitude() -> float:
    """Retorna a magnitude do slip com micro-lag (para feeling)"""
    return lagged_slip_local.length()

func get_average_slip_direction() -> Vector2:
    """Retorna a dire√ß√£o normalizada do slip m√©dio"""
    return average_slip_local.normalized() if average_slip_local.length_squared() > 0.0 else Vector2.ZERO

func get_lagged_slip_direction() -> Vector2:
    """Retorna a dire√ß√£o normalizada do slip com lag"""
    return lagged_slip_local.normalized() if lagged_slip_local.length_squared() > 0.0 else Vector2.ZERO

func get_hysteresis_debug_info() -> Dictionary:
    """Informa√ß√µes detalhadas da histerese para debug"""
    return {
        "stored_energy": stored_energy,
        "residual_energy": residual_energy,
        "hysteresis_factor": hysteresis_factor,
        "last_slip_mag": last_slip_magnitude,
        "lagged_slip_mag": get_lagged_slip_magnitude(),
        # Para debug apenas - n√£o usar no solver
        "debug_effective": get_effective_grip_factor()
    }

# --- Propriedades computadas (conveni√™ncia) ---

func get_active_samples() -> Array[TireSample]:
    """Retorna apenas as amostras que contribu√≠ram para o patch"""
    var active_samples: Array[TireSample] = []
    for sample in samples:
        if sample.valid and sample.penetration > 0.0:
            active_samples.append(sample)
    return active_samples

func get_sample_count() -> int:
    """N√∫mero total de amostras"""
    return samples.size()

func is_valid() -> bool:
    """Patch cont√©m dados v√°lidos para c√°lculos f√≠sicos"""
    return valid and contributing_samples > 0

func get_timestamp() -> float:
    """Timestamp da √∫ltima atualiza√ß√£o"""
    return timestamp

# --- M√©todos para integra√ß√£o com solver ---

func get_effective_grip_factor() -> float:
    """
    Retorna fator de grip combinando histerese e confian√ßa.
    Superf√≠cie ruim n√£o s√≥ tem menos grip, mas se recupera pior.
    
    üîπ Combina√ß√£o final dos efeitos de histerese:
    1. Histerese simples (stored_energy ‚Üí hysteresis_factor)
    2. Mem√≥ria residual (residual_energy)
    3. Modula√ß√£o por confian√ßa da superf√≠cie
    """
    # Confian√ßa mapeada para [0.5, 1.0] - mesmo superf√≠cie ruim tem alguma recupera√ß√£o
    var confidence_factor = lerp(CONFIDENCE_HYSTERESIS_MULTIPLIER, 1.0, patch_confidence)
    return hysteresis_factor * confidence_factor

func get_grip_modulation_factors() -> Dictionary:
    """
    Retorna fatores separados para o solver combinar apropriadamente.
    AVISO: O solver deve escolher entre usar get_effective_grip_factor() ou combinar manualmente.
    
    üîπ Cont√©m ambos os componentes da histerese:
    1. stored_energy (histerese simples)
    2. residual_energy (mem√≥ria residual)
    """
    return {
        "hysteresis": hysteresis_factor,
        "confidence": patch_confidence,
        "confidence_factor": lerp(CONFIDENCE_HYSTERESIS_MULTIPLIER, 1.0, patch_confidence),
        "effective": get_effective_grip_factor(),
        "lagged_slip": lagged_slip_local,  # Para sensa√ß√£o de massa
        "stored_energy": stored_energy,    # üîπ Histerese simples
        "residual_energy": residual_energy # üîπ Mem√≥ria residual
    }

func get_thermal_state() -> float:
    """
    Estado t√©rmico normalizado [0..1] baseado na histerese
    0 = frio, 1 = superaquecido (apenas unidades abstratas)
    
    üîπ Representa√ß√£o direta da histerese simples
    """
    return clamp(stored_energy / MAX_STORED_ENERGY, 0.0, 1.0)

# --- Representa√ß√£o para debug ---

func _to_string() -> String:
    return "ContactPatch(valid=%s, samples=%d/%d, conf=%.2f, hyst=%.2f, eff=%.2f, E=%.2f/%.2f)" % [
        valid, 
        contributing_samples, 
        samples.size(),
        patch_confidence,
        hysteresis_factor,
        get_effective_grip_factor(),
        stored_energy,      # üîπ Histerese simples
        residual_energy     # üîπ Mem√≥ria residual
    ]

func get_debug_info() -> Dictionary:
    """Informa√ß√µes detalhadas para debug"""
    var factors = get_grip_modulation_factors()
    
    return {
        "valid": valid,
        "timestamp": timestamp,
        "samples_total": samples.size(),
        "samples_contributing": contributing_samples,
        "center_local": center_of_pressure_local,
        "normal_local": average_normal_local,
        "slip_raw": average_slip_local,
        "slip_lagged": lagged_slip_local,
        "slip_raw_mag": get_average_slip_magnitude(),
        "slip_lag_mag": get_lagged_slip_magnitude(),
        "total_weight": total_contact_weight,
        "max_penetration": max_penetration,
        "confidence": patch_confidence,
        "hysteresis": get_hysteresis_debug_info(),
        "grip_factors": factors,
        "thermal_state": get_thermal_state(),
        # üîπ Destaque para os dois componentes principais
        "hysteresis_simple": {
            "stored_energy": stored_energy,
            "recovery_rate": HYSTERESIS_RECOVERY_SLOW if stored_energy > ENERGY_THRESHOLD else HYSTERESIS_RECOVERY_FAST,
            "factor": hysteresis_factor
        },
        "residual_memory": {
            "energy": residual_energy,
            "decay_rate": RESIDUAL_DECAY_RATE,
            "directional_noise": (residual_energy / MAX_STORED_ENERGY) * RESIDUAL_DIRECTIONAL_NOISE
        }
    }