# res://core/input/raycast/GeometryEngine.gd
# Motor matemático de raycast – único, sem duplicação em Nodes.
# Uso: instanciar e chamar sample_contact() a cada frame.
class_name GeometryEngine extends RefCounted

# ------------------------------------------------------------------------------
# Estruturas internas de dados (mantidas para clareza)
# ------------------------------------------------------------------------------
class RaycastData:
	var origin_world: Vector3
	var hit_position: Vector3
	var hit_normal: Vector3
	var compression: float          # metros
	var compression_normalized: float
	var confidence: float
	var is_contact: bool
	var distance: float
	var last_compression: float
	
	func _init():
		origin_world = Vector3.ZERO
		hit_position = Vector3.ZERO
		hit_normal = Vector3.UP
		compression = 0.0
		compression_normalized = 0.0
		confidence = 0.0
		is_contact = false
		distance = 0.0
		last_compression = 0.0

class RaycastAnchorResult:
	var has_contact: bool
	var avg_normal: Vector3
	var avg_contact_point: Vector3
	var compression: float
	var compression_normalized: float
	var max_compression: float
	var contact_patch_width: float
	var confidence: float
	var active_ray_count: int
	var ray_contacts: Array        # Array de dicionários
	var contact_patch_area: float
	var penetration_depth: float
	var stability_score: float
	var physical_constraints: Dictionary
	var temporal_data: Dictionary
	
	func _init():
		has_contact = false
		avg_normal = Vector3.UP
		avg_contact_point = Vector3.ZERO
		compression = 0.0
		compression_normalized = 0.0
		max_compression = 0.0
		contact_patch_width = 0.0
		confidence = 0.0
		active_ray_count = 0
		ray_contacts = []
		contact_patch_area = 0.0
		penetration_depth = 0.0
		stability_score = 0.0
		physical_constraints = {}
		temporal_data = {}

# ------------------------------------------------------------------------------
# Estado interno (histórico, última execução, configuração atual)
# ------------------------------------------------------------------------------
var _ray_origins_local: PackedVector3Array
var _current_ray_data: Array[RaycastData] = []
var _last_raycast_results: RaycastAnchorResult
var _contact_history: PackedByteArray      # bools como bytes (0/1)
var _compression_history: PackedFloat32Array
var _last_update_time: float = 0.0

# Configurações (atualizadas a cada sample_contact)
var _raycast_count: int
var _tire_width: float
var _max_suspension_travel: float
var _ray_origin_height: float
var _ray_length: float
var _ground_collision_mask: int
var _enable_temporal_dynamics: bool
var _raycast_compute_extended_metrics: bool

# Espaço físico (recebido na chamada)
var _space_state: PhysicsDirectSpaceState3D

# ------------------------------------------------------------------------------
# Inicialização
# ------------------------------------------------------------------------------
func _init():
	_last_raycast_results = RaycastAnchorResult.new()
	_contact_history = PackedByteArray()
	_compression_history = PackedFloat32Array()
	# histórico para 10 frames
	for i in range(10):
		_contact_history.append(0)
		_compression_history.append(0.0)

# ------------------------------------------------------------------------------
# API pública – único ponto de entrada
# ------------------------------------------------------------------------------
## Executa raycasts, processa métricas e retorna o resultado agregado em dicionário.
## Parâmetros:
##   direct_space_state : PhysicsDirectSpaceState3D – estado físico do frame
##   config : Dictionary – chaves obrigatórias: "global_transform" (Transform3D)
##            e quaisquer parâmetros listados abaixo (defaults internos)
##   now_s : float – timestamp atual em segundos (para dinâmica temporal)
func sample_contact(
	direct_space_state: PhysicsDirectSpaceState3D,
	config: Dictionary,
	now_s: float
) -> Dictionary:
	# ---- 1. Extrair configuração com defaults ----
	var global_transform: Transform3D = config.get("global_transform", Transform3D.IDENTITY)
	_raycast_count = config.get("raycast_count", 5)
	_tire_width = config.get("tire_width", 0.205)
	_max_suspension_travel = config.get("max_suspension_travel", 0.25)
	_ray_origin_height = config.get("ray_origin_height", 0.05)
	_ray_length = config.get("ray_length", 0.35)
	_ground_collision_mask = config.get("ground_collision_mask", 1)
	_enable_temporal_dynamics = config.get("enable_temporal_dynamics", true)
	_raycast_compute_extended_metrics = config.get("raycast_compute_extended_metrics", false)
	
	# ---- 2. Delta temporal ----
	var delta = now_s - _last_update_time
	if delta <= 0.0 or _last_update_time == 0.0:
		delta = 0.016  # fallback 60 FPS
	_last_update_time = now_s
	
	# ---- 3. Atualizar espaço físico ----
	_space_state = direct_space_state
	
	# ---- 4. Recalcular origens dos raios (config pode ter mudado) ----
	_calculate_ray_origins()
	
	# ---- 5. Garantir array de dados compatível com quantidade de raios ----
	if _current_ray_data.size() != _raycast_count:
		_current_ray_data.clear()
		for i in range(_raycast_count):
			_current_ray_data.append(RaycastData.new())
	
	# ---- 6. Executar raycasts e agregar ----
	var contact_points: Array = []
	var active_rays: int = 0
	var total_compression: float = 0.0
	var max_comp: float = 0.0
	var avg_normal: Vector3 = Vector3.ZERO
	var avg_contact: Vector3 = Vector3.ZERO
	
	for i in range(_raycast_count):
		var ray_data: RaycastData = _current_ray_data[i]
		ray_data.last_compression = ray_data.compression
		
		# origem no espaço mundial
		ray_data.origin_world = global_transform * _ray_origins_local[i]
		
		# query de raycast
		var query := PhysicsRayQueryParameters3D.new()
		query.from = ray_data.origin_world
		query.to = ray_data.origin_world + Vector3(0, -_ray_length, 0)
		query.collision_mask = _ground_collision_mask
		
		var result: Dictionary = _space_state.intersect_ray(query)
		
		if not result.is_empty():
			ray_data.hit_position = result.position
			ray_data.hit_normal = result.normal
			ray_data.distance = ray_data.origin_world.distance_to(ray_data.hit_position)
			ray_data.compression = _calculate_compression_meters(ray_data.distance)
			ray_data.compression_normalized = ray_data.compression / _max_suspension_travel
			ray_data.is_contact = ray_data.compression > 0.001
			ray_data.confidence = 1.0
			
			if ray_data.is_contact:
				active_rays += 1
				total_compression += ray_data.compression
				max_comp = maxf(max_comp, ray_data.compression)
				avg_normal += ray_data.hit_normal
				avg_contact += ray_data.hit_position
				contact_points.append({
					"position": ray_data.hit_position,
					"normal": ray_data.hit_normal,
					"compression": ray_data.compression,
					"compression_normalized": ray_data.compression_normalized,
					"ray_index": i
				})
		else:
			# sem contato
			ray_data.hit_position = ray_data.origin_world + Vector3(0, -_ray_length, 0)
			ray_data.hit_normal = Vector3.UP
			ray_data.distance = _ray_length
			ray_data.compression = 0.0
			ray_data.compression_normalized = 0.0
			ray_data.is_contact = false
			ray_data.confidence = 0.0
	
	# ---- 7. Dinâmica temporal (se habilitada) ----
	var temporal_data: Dictionary = {}
	if _enable_temporal_dynamics:
		temporal_data = _calculate_temporal_dynamics(active_rays, total_compression, avg_normal, delta)
	
	# ---- 8. Montar resultado agregado ----
	var result_obj := RaycastAnchorResult.new()
	result_obj.has_contact = active_rays > 0
	result_obj.active_ray_count = active_rays
	result_obj.ray_contacts = contact_points
	
	if active_rays > 0:
		result_obj.avg_normal = (avg_normal / active_rays).normalized()
		result_obj.avg_contact_point = avg_contact / active_rays
		result_obj.compression = total_compression / active_rays
		result_obj.compression_normalized = result_obj.compression / _max_suspension_travel
		result_obj.max_compression = max_comp
		result_obj.confidence = _calculate_confidence(active_rays, _raycast_count, result_obj.compression)
		
		if _raycast_compute_extended_metrics:
			result_obj.contact_patch_width = _calculate_contact_patch_width(contact_points, global_transform)
			result_obj.contact_patch_area = _estimate_contact_patch_area(result_obj.contact_patch_width, result_obj.compression)
			result_obj.penetration_depth = _calculate_penetration_depth(contact_points)
			result_obj.stability_score = _calculate_stability_score(contact_points, global_transform)
		
		result_obj.physical_constraints = _calculate_physical_constraints(contact_points, result_obj.avg_normal, global_transform)
		result_obj.temporal_data = temporal_data
	else:
		# valores padrão sem contato
		result_obj.avg_normal = Vector3.UP
		result_obj.avg_contact_point = Vector3.ZERO
		result_obj.compression = 0.0
		result_obj.compression_normalized = 0.0
		result_obj.max_compression = 0.0
		result_obj.confidence = 0.0
		result_obj.physical_constraints = _get_default_constraints(global_transform.origin)
		result_obj.temporal_data = temporal_data
	
	# ---- 9. Atualizar histórico ----
	_update_contact_history(result_obj.has_contact, result_obj.compression)
	
	# ---- 10. Salvar para referência futura ----
	_last_raycast_results = result_obj
	
	# ---- 11. Converter para dicionário e retornar ----
	return _raycast_anchor_result_to_dict(result_obj)

# ------------------------------------------------------------------------------
# Métodos internos (adaptados da versão original)
# ------------------------------------------------------------------------------
func _calculate_ray_origins() -> void:
	var half_width: float = _tire_width * 0.5
	var ray_spacing: float = _tire_width / maxf(_raycast_count - 1, 1)
	_ray_origins_local = PackedVector3Array()
	for i in range(_raycast_count):
		var x_pos: float = -half_width + (i * ray_spacing)
		_ray_origins_local.append(Vector3(x_pos, -_ray_origin_height, 0))

func _calculate_compression_meters(hit_distance: float) -> float:
	return maxf(0.0, _ray_length - hit_distance)

func _calculate_physical_constraints(
	contact_points: Array,
	avg_normal: Vector3,
	global_transform: Transform3D
) -> Dictionary:
	if contact_points.is_empty():
		return _get_default_constraints(global_transform.origin)
	
	var min_height: float = INF
	var max_height: float = -INF
	var leftmost: float = INF
	var rightmost: float = -INF
	
	for contact in contact_points:
		var pos: Vector3 = contact["position"]
		min_height = minf(min_height, pos.y)
		max_height = maxf(max_height, pos.y)
		var local_x: float = (global_transform.affine_inverse() * pos).x
		leftmost = minf(leftmost, local_x)
		rightmost = maxf(rightmost, local_x)
	
	return {
		"max_penetration": _max_suspension_travel * 1.1,
		"min_penetration": 0.0,
		"max_contact_width": _tire_width * 1.2,
		"min_contact_width": 0.0,
		"reference_plane_normal": avg_normal,
		"reference_plane_height": (min_height + max_height) * 0.5,
		"ground_height_range": max_height - min_height if max_height != -INF else 0.0,
		"left_boundary": leftmost if leftmost != INF else -_tire_width * 0.5,
		"right_boundary": rightmost if rightmost != -INF else _tire_width * 0.5,
		"timestamp": Time.get_ticks_msec(),
		"valid_for_seconds": 0.1
	}

func _get_default_constraints(global_position: Vector3) -> Dictionary:
	return {
		"max_penetration": _max_suspension_travel,
		"min_penetration": 0.0,
		"max_contact_width": _tire_width,
		"min_contact_width": 0.0,
		"reference_plane_normal": Vector3.UP,
		"reference_plane_height": global_position.y,
		"ground_height_range": 0.0,
		"left_boundary": -_tire_width * 0.5,
		"right_boundary": _tire_width * 0.5,
		"timestamp": Time.get_ticks_msec(),
		"valid_for_seconds": 0.1
	}

func _calculate_temporal_dynamics(
	active_rays: int,
	total_compression: float,
	avg_normal: Vector3,
	delta: float
) -> Dictionary:
	if delta <= 0.0:
		return {
			"compression_velocity": 0.0,
			"normal_variation": 0.0,
			"event_score": 0.0
		}
	
	var current_avg_compression: float = 0.0
	if active_rays > 0:
		current_avg_compression = total_compression / active_rays
	
	var compression_velocity: float = 0.0
	if _compression_history.size() > 0:
		var last_avg: float = _compression_history[_compression_history.size() - 1]
		compression_velocity = (current_avg_compression - last_avg) / delta
	
	var normal_variation: float = 0.0
	if _last_raycast_results and _last_raycast_results.has_contact:
		var current_normal: Vector3
		if active_rays > 0:
			current_normal = (avg_normal / active_rays).normalized()
		else:
			current_normal = Vector3.UP
		var dot: float = _last_raycast_results.avg_normal.dot(current_normal)
		normal_variation = 1.0 - absf(dot)
	
	var event_score: float = absf(compression_velocity) * 0.5 + normal_variation * 0.5
	
	return {
		"compression_velocity": compression_velocity,
		"normal_variation": normal_variation,
		"event_score": event_score,
		"delta_time": delta,
		"timestamp": Time.get_ticks_msec()
	}

func _calculate_confidence(active_rays: int, total_rays: int, avg_compression: float) -> float:
	var coverage_ratio: float = float(active_rays) / float(total_rays)
	var compression_factor: float = clampf(avg_compression / _max_suspension_travel, 0.0, 1.0)
	var stability_factor: float = _calculate_stability_factor()
	return clampf(coverage_ratio * 0.4 + compression_factor * 0.4 + stability_factor * 0.2, 0.0, 1.0)

func _update_contact_history(has_contact_now: bool, current_compression: float = 0.0) -> void:
	if _contact_history.size() >= 10:
		_contact_history.remove_at(0)
		_compression_history.remove_at(0)
	_contact_history.append(1 if has_contact_now else 0)
	_compression_history.append(current_compression)

func _calculate_stability_factor() -> float:
	if _contact_history.is_empty():
		return 0.0
	var contact_count: int = 0
	for i in range(_contact_history.size()):
		if _contact_history[i] == 1:
			contact_count += 1
	return float(contact_count) / float(_contact_history.size())

func _calculate_contact_patch_width(contact_points: Array, global_transform: Transform3D) -> float:
	if contact_points.size() < 2:
		return 0.0
	var leftmost: float = INF
	var rightmost: float = -INF
	for contact in contact_points:
		var local_x: float = (global_transform.affine_inverse() * contact["position"]).x
		leftmost = minf(leftmost, local_x)
		rightmost = maxf(rightmost, local_x)
	return absf(rightmost - leftmost)

func _estimate_contact_patch_area(width: float, compression: float) -> float:
	var length_estimate: float = 0.33 * (compression / _max_suspension_travel) * 2.0
	return width * length_estimate

func _calculate_penetration_depth(contact_points: Array) -> float:
	if contact_points.is_empty():
		return 0.0
	var total_depth: float = 0.0
	for contact in contact_points:
		total_depth += contact["compression"]
	return total_depth / contact_points.size()

func _calculate_stability_score(contact_points: Array, global_transform: Transform3D) -> float:
	if contact_points.size() < 2:
		return 0.0
	var positions: PackedFloat32Array = PackedFloat32Array()
	for contact in contact_points:
		positions.append((global_transform.affine_inverse() * contact["position"]).x)
	positions.sort()
	var min_x: float = positions[0]
	var max_x: float = positions[positions.size() - 1]
	var center: float = (min_x + max_x) * 0.5
	var balance_score: float = 1.0 - absf(center) / (_tire_width * 0.5)
	var coverage_score: float = float(contact_points.size()) / float(_raycast_count)
	return clampf(balance_score * coverage_score, 0.0, 1.0)

# Conversão do objeto resultado para dicionário (formato de retorno)
func _raycast_anchor_result_to_dict(r: RaycastAnchorResult) -> Dictionary:
	return {
		"has_contact": r.has_contact,
		"avg_normal": r.avg_normal,
		"avg_contact_point": r.avg_contact_point,
		"compression": r.compression,
		"compression_normalized": r.compression_normalized,
		"max_compression": r.max_compression,
		"contact_patch_width": r.contact_patch_width,
		"confidence": r.confidence,
		"active_ray_count": r.active_ray_count,
		"ray_contacts": r.ray_contacts.duplicate(),   # cópia superficial
		"contact_patch_area": r.contact_patch_area,
		"penetration_depth": r.penetration_depth,
		"stability_score": r.stability_score,
		"physical_constraints": r.physical_constraints.duplicate(),
		"temporal_data": r.temporal_data.duplicate()
	}