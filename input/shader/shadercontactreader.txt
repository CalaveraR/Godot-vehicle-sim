class_name ShaderContactReader
extends Node

# ==============================================================================
# CONFIGURAÇÃO EXPORTADA
# ==============================================================================

## Dimensões da grade de amostras (alterar antes da inicialização)
@export var grid_w: int = 90
@export var grid_h: int = 120

## Dimensões físicas do pneu (alterar antes da inicialização)
@export var tire_width: float = 0.205
@export var tire_radius: float = 0.33

## Textura com dados de contato (FORMAT_RGBAF obrigatório)
@export var shader_texture: Texture2D

# ==============================================================================
# CLASSES INTERNAS (AUTOCONTIDAS)
# ==============================================================================

## Representa uma amostra individual da superfície de contato.
class TireSample:
	## Posição global do ponto de contato
	var position: Vector3
	## Normal da superfície (não preenchida pelo shader – mantida como zero)
	var normal: Vector3
	## Penetração (metros) – valor positivo indica contato
	var penetration: float
	## Velocidade de penetração (m/s) – não calculada internamente (0 por padrão)
	var penetration_velocity: float
	## Velocidade relativa do ponto (não calculada internamente)
	var relative_velocity: Vector3
	## Deslizamentos no espaço local do pneu: x = longitudinal, y = lateral
	var slip: Vector2
	## Confiança da medição [0..1]
	var confidence: float
	## Coordenada coluna na grade (x)
	var grid_x: int
	## Coordenada linha na grade (y)
	var grid_y: int
	## Origem da amostra (sempre SOURCE_SHADER)
	var source: int
	## Timestamp da leitura (segundos)
	var timestamp: float
	
	const SOURCE_SHADER = 0
	
	func _init(
		p_position: Vector3,
		p_normal: Vector3,
		p_penetration: float,
		p_penetration_velocity: float,
		p_relative_velocity: Vector3,
		p_slip: Vector2,
		p_confidence: float,
		p_grid_x: int,
		p_grid_y: int,
		p_source: int,
		p_timestamp: float
	):
		position = p_position
		normal = p_normal
		penetration = p_penetration
		penetration_velocity = p_penetration_velocity
		relative_velocity = p_relative_velocity
		slip = p_slip
		confidence = p_confidence
		grid_x = p_grid_x
		grid_y = p_grid_y
		source = p_source
		timestamp = p_timestamp

# ==============================================================================
# DADOS INTERNOS
# ==============================================================================

var _cell_local_pos: PackedVector3Array = []
var _initialized: bool = false

# ==============================================================================
# INICIALIZAÇÃO (PRIVADA)
# ==============================================================================

## Constrói as posições locais da grade do pneu.
## Chamada automaticamente na primeira leitura se necessário.
func _initialize() -> void:
	if _initialized:
		return
	
	_cell_local_pos.clear()
	var step_deg = 3.0  # ângulo fixo entre camadas longitudinais
	
	for iy in range(grid_h):
		var angle_deg = iy * step_deg
		var theta = deg_to_rad(angle_deg)
		for ix in range(grid_w):
			var u = float(ix) / float(grid_w - 1) - 0.5
			var local_pt = Vector3(u * tire_width, 0.0, -tire_radius)
			var rot = Basis(Vector3.UP, theta)
			var rotated = rot * local_pt
			_cell_local_pos.append(rotated)
	
	_initialized = true

## Reforça a reinicialização quando parâmetros geométricos forem alterados.
func _rebuild() -> void:
	_initialized = false
	_initialize()

# ==============================================================================
# INTERFACE PÚBLICA (100% INPUT)
# ==============================================================================

## Define ou troca a textura de origem dos dados.
func set_source_texture(tex: Texture2D) -> void:
	shader_texture = tex

## Lê os dados atuais do shader e retorna um array de amostras.
## @param now_s: Timestamp atual (segundos) – será anexado a cada amostra.
## @return Array[TireSample] – lista de amostras processadas.
func read_samples(now_s: float) -> Array[TireSample]:
	if not _initialized:
		_initialize()
	
	if not shader_texture:
		return []
	
	var img: Image = shader_texture.get_image()
	if img.get_format() != Image.FORMAT_RGBAF:
		push_error("ShaderContactReader: textura deve estar no formato FORMAT_RGBAF (float).")
		return []
	
	var data: PackedByteArray = img.get_data()
	var bytes_per_pixel = 16
	var expected_cells = grid_w * grid_h
	var available_cells = data.size() / bytes_per_pixel
	
	if available_cells < expected_cells:
		push_warning(
			"ShaderContactReader: textura menor que a grade esperada. "
			+ "Esperado %d células, obtido %d." % [expected_cells, available_cells]
		)
	
	var total_cells = min(expected_cells, available_cells)
	var samples: Array[TireSample] = []
	var global_xform = global_transform  # usa o transform do próprio nó
	
	for idx in range(total_cells):
		var offset = idx * bytes_per_pixel
		
		# Extrai valores brutos do shader
		var penetration = max(data.decode_float(offset), 0.0)
		var slip_x = data.decode_float(offset + 4)
		var slip_y = data.decode_float(offset + 8)
		var conf = clamp(data.decode_float(offset + 12), 0.0, 1.0)
		
		# Posição global: transform aplicado à posição local pré‑computada
		var world_pos = global_xform * _cell_local_pos[idx]
		
		# Cria a amostra com velocidade de penetração zero (cálculo externo)
		var sample = TireSample.new(
			world_pos,
			Vector3.ZERO,        # normal – será inferida posteriormente
			penetration,
			0.0,                # penetration_velocity – não calculada aqui
			Vector3.ZERO,       # relative_velocity – não calculada aqui
			Vector2(slip_x, slip_y),
			conf,
			idx % grid_w,
			idx / grid_w,
			TireSample.SOURCE_SHADER,
			now_s
		)
		samples.append(sample)
	
	return samples

# ==============================================================================
# SETTERS COM REINICIALIZAÇÃO AUTOMÁTICA (OPCIONAL)
# ==============================================================================

## Altera a largura da grade e reconstrói as posições.
func set_grid_w(value: int) -> void:
	if value != grid_w:
		grid_w = value
		_rebuild()

## Altera a altura da grade e reconstrói as posições.
func set_grid_h(value: int) -> void:
	if value != grid_h:
		grid_h = value
		_rebuild()

## Altera a largura do pneu e reconstrói as posições.
func set_tire_width(value: float) -> void:
	if value != tire_width:
		tire_width = value
		_rebuild()

## Altera o raio do pneu e reconstrói as posições.
func set_tire_radius(value: float) -> void:
	if value != tire_radius:
		tire_radius = value
		_rebuild()